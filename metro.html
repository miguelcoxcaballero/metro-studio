<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Metro Studio</title>
<script src="https://cdn.tailwindcss.com"></script>

<style>
  :root{
    --bg0:#f8f9fa;
    --bg1:#f1f3f4;
    --ink:#202124;
    --soft:#5f6368;
    --lc:#1a73e8;
    --accent: #3b82f6;
  }

  html,body{
    margin:0; width:100%; height:100%;
    overflow:hidden; user-select:none;
    font-family:"Google Sans", system-ui, -apple-system, sans-serif;
    background: 
      radial-gradient(circle at 50% 50%, #ffffff 0%, #f1f3f4 100%);
  }

  #app-svg{
    display:block; width:100%; height:100%;
    cursor:crosshair;
    touch-action:none;
  }
  
  #app-svg.panning { cursor: grabbing; }

  /* Line Group for Synchronized Hover */
  .line-group {
    pointer-events: stroke;
    cursor: pointer;
  }
  
  /* Synchronized thickening on group hover */
  .line-group:hover .path, 
  .line-group:hover .line-tbar { 
    stroke-width: 14px !important; 
  }

  .path, .line-tbar {
    fill:none;
    stroke-linecap:round;
    stroke-linejoin:round;
    transition: opacity 0.3s ease, stroke-width 0.2s ease;
  }
  
  /* State classes for the line */
  .path.editing-focus, .line-tbar.editing-focus { stroke-width: 12px !important; filter: drop-shadow(0 0 4px rgba(0,0,0,0.1)); }
  .path.dimmed, .line-tbar.dimmed { opacity: 0.15 !important; }

  #ghostShadow{ pointer-events:none; opacity:0.1; }
  #ghost{
    pointer-events:none;
    opacity:0.8;
    filter: drop-shadow(0 4px 6px rgba(0,0,0,0.1));
  }

  /* Stations */
  .stop-shape{
    fill:#ffffff;
    stroke:#3c4043;
    stroke-width:4.5;
    transition: transform 0.2s cubic-bezier(0.2, 0, 0, 1), stroke 0.2s;
    transform-box: fill-box;
    transform-origin:center;
  }
  
  .stop-side-square {
    stroke-width: 0;
    transition: transform 0.2s ease;
    transform-box: fill-box;
    transform-origin: center;
  }

  .stop-inline-dot {
    fill: #ffffff;
    stroke: none;
    pointer-events: none;
  }

  /* Outline for orphan style 3 stops */
  .stop-orphan-dot {
    fill: none;
    stroke: var(--ink);
    stroke-width: 2px;
    pointer-events: none;
  }

  /* Highlight Ring and Guide */
  .stop-ring{
    fill:none;
    stroke: var(--lc);
    stroke-width: 0;
    opacity: 0;
    transition: opacity 0.2s ease, stroke-width 0.2s ease;
  }

  .stop.hover .stop-shape, .stop.hover .stop-side-square { 
    transform: scale(1.25);
    stroke: var(--accent);
  }

  /* Visual guide: disappears on hover */
  .stop.in-edited-line:not(.hover) .stop-ring {
    opacity: 0.35;
    stroke-width: 10;
  }
  
  .stop.onSel .stop-ring{ 
    opacity: 0.9;
    stroke-width: 6;
  }

  .stop.pulse .stop-shape, .stop.pulse .stop-side-square { 
    animation: pulseAnim 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
  }

  .stop-label {
    fill: #3c4043;
    font-size: 12px;
    font-weight: 700;
    pointer-events: none;
    text-shadow: 0 0 4px white, 0 0 4px white;
    transition: opacity 0.2s;
  }

  @keyframes pulseAnim{
    0%{ transform:scale(1); }
    50%{ transform:scale(1.4); }
    100%{ transform:scale(1); }
  }

  @keyframes selectPulse {
    0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4); border-color: rgba(59, 130, 246, 0.5); }
    70% { box-shadow: 0 0 0 8px rgba(59, 130, 246, 0); border-color: rgba(59, 130, 246, 1); }
    100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); border-color: rgba(59, 130, 246, 0.5); }
  }

  .handle{ 
    cursor: grab; 
    transition: transform 0.2s;
  }
  .handle:active{ cursor: grabbing; transform: scale(1.1); }

  header, #ui-panel {
    background: rgba(255,255,255,0.9) !important;
    backdrop-filter: blur(12px);
    border: 1px solid rgba(0,0,0,0.05);
  }

  .line-card.active {
    animation: selectPulse 2s infinite;
  }

  #stop-popup {
    position: fixed;
    background: white;
    border-radius: 20px;
    box-shadow: 0 12px 32px rgba(0,0,0,0.15);
    padding: 16px;
    min-width: 240px;
    z-index: 100;
    display: none;
    animation: popupIn 0.2s cubic-bezier(0.2, 0, 0, 1);
  }
  @keyframes popupIn {
    from { opacity: 0; transform: translateY(10px) scale(0.95); }
    to { opacity: 1; transform: translateY(0) scale(1); }
  }

  #stop-popup input {
    width: 100%;
    border: 2px solid #f1f3f4;
    font-weight: 600;
    padding: 10px 12px;
    border-radius: 12px;
    background: #f8f9fa;
    margin-bottom: 16px;
    transition: all 0.2s;
  }
  #stop-popup input:focus { outline: none; border-color: var(--accent); background: white; }
  
  .popup-section-title {
    font-size: 11px;
    text-transform: uppercase;
    font-weight: 800;
    color: #80868b;
    margin-bottom: 8px;
    letter-spacing: 0.08em;
  }
  
  .popup-btn {
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
    padding: 10px;
    border-radius: 12px;
    font-size: 13px;
    font-weight: 600;
    color: #3c4043;
    transition: background 0.2s;
  }
  .popup-btn:hover { background: #f1f3f4; }
  .popup-btn.danger { color: #d93025; }
  .popup-btn.danger:hover { background: #fce8e6; }

  .selector-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 6px;
    margin-bottom: 16px;
  }
  .opt-btn {
    aspect-ratio: 1;
    border: 2px solid #f1f3f4;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
    background: white;
  }
  .opt-btn:hover { border-color: #dadce0; }
  .opt-btn.active { border-color: var(--accent); background: #e8f0fe; color: var(--accent); }

  .line-tag {
    display: inline-flex;
    width: 12px; height: 12px;
    border-radius: 50%;
    margin-right: 4px;
  }
</style>
</head>

<body>
  <header class="absolute top-6 left-6 right-6 h-16 rounded-2xl flex items-center justify-between px-8 shadow-sm z-50">
    <div class="flex items-center gap-3 text-gray-900 font-bold tracking-tight">
      <div class="p-1 text-blue-600 flex items-center justify-center">
        <!-- New Train Icon -->
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 146.85 146.57" class="w-10 h-10">
          <path fill="currentColor" d="M 49.107143,133.17765 L 26.964286,133.17765 L 45,118.44551 L 35,118.50614 C 35,118.50614 32,117.57051 30,115.57051 C 28,113.57051 27,109.10591 27,109.10591 L 27,29.570511 C 27,29.570511 26.642857,28.041576 29.642857,24.570511 C 32.642857,21.099446 36,21.570511 36,21.570511 L 55,21.570511 C 55,21.570511 55,18.570511 57,16.570511 C 59,14.570511 62,14.973159 62,14.973159 L 88,14.973159 C 88,14.973159 91.160476,15.25284 92.714286,17.302654 C 94.280187,19.368419 93.990115,21.63516 93.990115,21.63516 L 113.03571,21.731225 C 113.03571,21.731225 117.28571,21.01694 119.55357,25.106225 C 121.72253,29.017186 121,31.570511 121,31.570511 L 121,109.10591 C 121,109.10591 121.375,114.08837 119.375,116.08837 C 117.375,118.08837 112.01786,118.55265 112.01786,118.55265 L 103.80357,118.55265 L 121,133.64194 L 100.08929,133.74908 L 89.928571,118.64194 L 57.017857,118.6598 L 49.107143,133.17765 Z"/>
          <rect x="38.407105" y="32.570511" width="71.592895" height="34" rx="4" ry="4" fill="#FFFFFF"/>
          <rect x="40" y="83.570511" width="16.432526" height="13.165013" rx="4" ry="4" fill="#FFFFFF"/>
          <rect x="93.067474" y="83.070511" width="16.432526" height="13.165013" rx="4" ry="4" fill="#FFFFFF"/>
        </svg>
      </div>
      Metro Studio
    </div>
    <div class="flex gap-3">
      <button onclick="$('inp').click()" class="px-5 py-2.5 hover:bg-gray-100 rounded-xl text-sm font-bold text-gray-600 transition-all">Import</button>
      <input id="inp" type="file" hidden onchange="io.import(this)">
      <button onclick="io.export()" class="px-6 py-2.5 bg-gray-900 hover:bg-black text-white rounded-xl text-sm font-bold shadow-lg transition-all">Export Project</button>
    </div>
  </header>

  <div id="ui-panel" class="absolute bottom-8 left-8 w-72 max-h-[45vh] overflow-y-auto rounded-2xl p-3 shadow-2xl z-40 flex flex-col-reverse gap-3 empty:hidden"></div>

  <div id="stop-popup">
    <div class="popup-section-title">Station Name</div>
    <input type="text" id="popup-stop-name" placeholder="E.g. Central Station..." spellcheck="false" oninput="app.updateStopName(this.value)">
    
    <div class="popup-section-title">Visual Style</div>
    <div class="selector-grid">
      <div class="opt-btn style-opt" onclick="app.updateStopStyle('standard', this)" title="Standard">
        <div class="w-4 h-4 rounded-full border-2 border-current"></div>
      </div>
      <div class="opt-btn style-opt" onclick="app.updateStopStyle('side-square', this)" title="Side">
        <div class="w-4 h-4 border-2 border-current"></div>
      </div>
      <div class="opt-btn style-opt" onclick="app.updateStopStyle('inline-dot', this)" title="Inline">
        <div class="w-2 h-2 rounded-full bg-current"></div>
      </div>
    </div>

    <div class="popup-section-title">Typography</div>
    <div class="selector-grid">
      <div class="opt-btn font-opt" style="font-family: sans-serif;" onclick="app.updateStopFont('sans-serif', this)">A</div>
      <div class="opt-btn font-opt" style="font-family: serif;" onclick="app.updateStopFont('serif', this)">A</div>
      <div class="opt-btn font-opt" style="font-family: monospace;" onclick="app.updateStopFont('monospace', this)">A</div>
      <div class="opt-btn font-opt" style="font-weight: 800;" onclick="app.updateStopFont('bold', this)">A</div>
      <div class="opt-btn font-opt" style="font-style: italic;" onclick="app.updateStopFont('italic', this)">A</div>
    </div>

    <button class="popup-btn danger" onclick="app.deleteCurrentStop()">
      <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg>
      Delete Station
    </button>

    <div class="mt-4 pt-4 border-t border-gray-100">
      <div class="popup-section-title">Lines at this station</div>
      <div id="popup-stop-lines" class="flex flex-wrap gap-2 px-1"></div>
    </div>
  </div>

  <svg id="app-svg" preserveAspectRatio="xMidYMid slice">
    <defs>
      <pattern id="grid-pattern" x="-20" y="-20" width="40" height="40" patternUnits="userSpaceOnUse">
        <circle cx="20" cy="20" r="1.2" fill="#dadce0"/>
      </pattern>
    </defs>
    <rect x="-10000" y="-10000" width="20000" height="20000" fill="url(#grid-pattern)"></rect>

    <g id="lines-layer"></g>
    <g id="edit-layer"></g>

    <polyline id="ghostShadow" fill="none" stroke="#000" stroke-width="16" stroke-linecap="round" stroke-linejoin="round" style="display:none"></polyline>
    <polyline id="ghost" fill="none" stroke="var(--lc)" stroke-width="11" stroke-linecap="round" stroke-linejoin="round" style="display:none"></polyline>

    <g id="handles-layer"></g>
    <g id="stops-layer"></g>
  </svg>

<script>
/* ========= CONFIGURATION ========= */
const GRID = 40;
const LINE_WIDTH = 10;
const LINE_SPACING = 12;
const MITER_LIMIT = 6; 
const TAP_THRESHOLD = 250; 
const MOVE_THRESHOLD = 5; 

let stops = [];
let lines = [];
let corridorOrders = {}; 

const colors = ['#EA4335','#4285F4','#34A853','#F4C20D','#AB47BC','#FF6D00','#00ACC1','#795548'];
let view = { x: 500, y: 375, w: 1000, h: 750 };

const appState = { selectedLineId: null, space: false, panStart: null, mouseRaw: {x:0, y:0}, popupStopId: null };

const gesture = {
  active: false, mode: null, moved: false, startTime: 0,
  startPt: null, startScreen: { x: 0, y: 0 }, 
  lid: null, liveNodes: [], tempPoint: null,
  anchorA: null, anchorB: null, lastAppliedHover: null,
  initialTargetStop: null,
  hoverStopId: null,
  touchLatch: new Set(),
  touchedStops: new Set() 
};

/* ========= UTILS ========= */
const $ = id => document.getElementById(id);
const attr = (el, a) => { for (const k in a) el.setAttribute(k, a[k]); };
const dist = (a,b) => Math.hypot(a.x-b.x, a.y-b.y);
const snap = v => Math.round(v / GRID) * GRID;
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const snapLen = v => Math.round(v / GRID) * GRID;

function getMousePos(evt){
  const svg = $('app-svg'), p = svg.createSVGPoint();
  p.x = evt.clientX; p.y = evt.clientY;
  return p.matrixTransform(svg.getScreenCTM().inverse());
}

function stopById(id){ return stops.find(s=>s.id===id); }
function lineById(id){ return lines.find(l=>l.id===id); }

function getStopNear(pos, d=36, excludeIds = new Set()){
  let best = null, bd = Infinity;
  const corridorsObj = buildCorridors();
  for(const s of stops){
    if(excludeIds && excludeIds.has(s.id)) continue;
    let md = minDistToStopVisual(pos, s, corridorsObj);
    if(md < d && md < bd){ bd = md; best = s; }
  }
  return best;
}

function pulseStop(id){
  const g = $(id); if(!g) return;
  g.classList.remove('pulse'); void g.offsetWidth; g.classList.add('pulse');
}

function distPointToSeg(p,a,b){
  const vx=b.x-a.x, vy=b.y-a.y, wx=p.x-a.x, wy=p.y-a.y;
  const vv = vx*vx+vy*vy || 1;
  let t = Math.max(0, Math.min(1,(wx*vx+vy*vy)/vv));
  return Math.hypot(p.x-(a.x+t*vx), p.y-(a.y+t*vy));
}

function getNormal(p1, p2) {
  const dx = p2.x - p1.x, dy = p2.y - p1.y;
  const len = Math.hypot(dx, dy) || 1;
  return { x: -dy / len, y: dx / len };
}

function pointsToAttr(pts){ return pts.map(p => `${p.x},${p.y}`).join(' '); }

function setView(){
  view.h = view.w * (window.innerHeight / window.innerWidth);
  attr($('app-svg'), { viewBox: `${view.x} ${view.y} ${view.w} ${view.h}` });
}

function setViewOnWheel(e){
  e.preventDefault();
  const nw = view.w * Math.pow(1.1, e.deltaY > 0 ? 1 : -1);
  if(nw<100 || nw>10000) return;
  const mx=e.offsetX/window.innerWidth, my=e.offsetY/window.innerHeight;
  view.x += mx*(view.w-nw);
  view.y += my*(view.h-(nw*(window.innerHeight / window.innerWidth)));
  view.w = nw; setView();
}

/* ========= GEOMETRY ========= */
function calculateRoute(p1, p2, influencePt){
  const A = { x: p1.x, y: p1.y }, B = { x: p2.x, y: p2.y };
  const dx = B.x - A.x, dy = B.y - A.y;
  const adx = Math.abs(dx), ady = Math.abs(dy);
  if(adx < 0.5 || ady < 0.5 || Math.abs(adx - ady) < 0.5) return [A, B];
  const sx = Math.sign(dx), sy = Math.sign(dy), diag = Math.min(adx, ady), extra = Math.abs(adx - ady), dom = (adx > ady) ? 'x' : 'y';
  let pre = extra / 2;
  if(influencePt){
    if(dom === 'x') pre = (influencePt.x - A.x) * sx - diag / 2;
    else pre = (influencePt.y - A.y) * sy - diag / 2;
  }
  pre = clamp(snapLen(pre), 0, extra);
  const pts = [A];
  const pushIfNew = (p) => { if(dist(pts[pts.length-1], p) > 0.5) pts.push(p); };
  if(dom === 'x'){
    pushIfNew({ x: A.x + sx*pre, y: A.y });
    pushIfNew({ x: A.x + sx*(pre+diag), y: A.y + sy*diag });
  } else {
    pushIfNew({ x: A.x, y: A.y + sy*pre });
    pushIfNew({ x: A.x + sx*diag, y: A.y + sy*(pre+diag) });
  }
  pushIfNew(B);
  return pts;
}

function densifyRoute(routePts){
  const out = [];
  for(let i=0;i<routePts.length;i++){
    const p = routePts[i];
    if(out.length===0) out.push({x:p.x,y:p.y});
    if(i===routePts.length-1) break;
    const q = routePts[i+1];
    const dx = q.x - p.x, dy = q.y - p.y;
    const steps = Math.round(Math.max(Math.abs(dx), Math.abs(dy)) / GRID) || 1;
    const sx = Math.sign(dx) * (Math.abs(dx)?GRID:0);
    const sy = Math.sign(dy) * (Math.abs(dy)?GRID:0);
    let cx = p.x, cy = p.y;
    for(let k=0;k<steps;k++){
      cx += sx; cy += sy;
      if(dist(out[out.length-1], {x:cx, y:cy}) > 0.5) out.push({x:cx,y:cy});
    }
  }
  return out;
}

function chunkKey(p, q){
  const ax = p.x, ay = p.y, bx = q.x, by = q.y;
  if (ax < bx || (ax === bx && ay <= by)) return `${ax},${ay}|${bx},${by}`;
  return `${bx},${by}|${ax},${ay}`;
}

function compressColinear(pts){
  if(pts.length<=2) return pts;
  const out = [pts[0]];
  for(let i=1;i<pts.length-1;i++){
    const a = out[out.length-1], b = pts[i], c = pts[i+1], abx=b.x-a.x, aby=b.y-a.y, bcx=c.x-b.x, bcy=c.y-b.y;
    if(abx*bcy - aby*bcx === 0) continue;
    out.push(b);
  }
  out.push(pts[pts.length-1]);
  return out;
}

function buildCorridors(){
  const map = {}, refs = {}; 
  for(const line of lines){
    if(!line.nodes || line.nodes.length<2) continue;
    for(let i=0;i<line.nodes.length-1;i++){
      const a = stopById(line.nodes[i]), b = stopById(line.nodes[i+1]);
      if(!a || !b) continue;
      const bendKey = [a.id, b.id].sort().join('-');
      let influence = (line.bends && line.bends[bendKey]) || { x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
      if (isNaN(influence.x) || isNaN(influence.y)) influence = { x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
      const dense = densifyRoute(calculateRoute(a, b, influence));
      for(let k=0;k<dense.length-1;k++){
        const p = dense[k], q = dense[k+1], key = chunkKey(p,q);
        if(!map[key]) map[key] = [];
        if(!map[key].includes(line.id)) map[key].push(line.id);
        if(!refs[key]) refs[key] = { dx: q.x - p.x, dy: q.y - p.y };
      }
    }
  }
  for(const key in map){
    if(corridorOrders[key]){
      const saved = corridorOrders[key].filter(id => map[key].includes(id));
      const extra = map[key].filter(id => !saved.includes(id));
      map[key] = [...saved, ...extra];
    }
  }
  return { map, refs };
}

function getCorridorInfoChunk(lineId, p, q, corridorsMap, refs){
  const key = chunkKey(p,q), corridor = corridorsMap?.[key];
  if(!corridor || corridor.length < 2) return { offset: 0, count: 1, index: 0, key, flip: 1 };
  const n = corridor.length, idx = corridor.indexOf(lineId), base = (idx - (n - 1)/2) * LINE_SPACING, ref = refs?.[key];
  let flip = 1; if(ref && ( (q.x - p.x)*ref.dx + (q.y - p.y)*ref.dy ) < 0) flip = -1;
  return { offset: base * flip, count: n, index: idx, key, flip };
}

function stopVisualPointsForHit(s, corridorsObj){
  const pts = [{ x: s.x, y: s.y }];
  const style = s.style || 'standard';
  const stopLines = lines.filter(l => l.nodes.includes(s.id));
  if((style === 'side-square' || style === 'inline-dot') && stopLines.length > 0){
      if(!corridorsObj) corridorsObj = buildCorridors();
      stopLines.forEach(l => {
        const idx = l.nodes.indexOf(s.id);
        const neighbor = stopById(l.nodes[idx+1]) || stopById(l.nodes[idx-1]);
        if(!neighbor) return;
        const dx = neighbor.x - s.x, dy = neighbor.y - s.y, dlen = Math.hypot(dx,dy)||1;
        const pAdj = { x: s.x + (dx/dlen)*GRID, y: s.y + (dy/dlen)*GRID };
        const info = getCorridorInfoChunk(l.id, s, pAdj, corridorsObj.map, corridorsObj.refs);
        const n = getNormal(s, pAdj);
        const lineX = s.x + n.x * info.offset, lineY = s.y + n.y * info.offset;
        pts.push({ x: lineX, y: lineY });
        if(style === 'side-square') pts.push({ x: lineX + n.x*12, y: lineY + n.y*12 });
      });
  }
  return pts;
}

function minDistToStopVisual(pos, s, corridorsObj){
  let md = Infinity;
  const pts = stopVisualPointsForHit(s, corridorsObj);
  for(const p of pts) md = Math.min(md, Math.hypot(p.x - pos.x, p.y - pos.y));
  return md;
}

function toggleStopOnLine(lineObj, sid, anchorA, anchorB, mousePos){
  const nodes = lineObj.nodes, idx = nodes.indexOf(sid);
  if(idx !== -1){
    if(nodes.length <= 2) return { a: anchorA, b: anchorB, changed: false };
    const prev = nodes[idx-1], next = nodes[idx+1];
    lineObj.nodes = nodes.filter(x => x !== sid);
    if(lineObj.bends) { 
      if (prev && sid) delete lineObj.bends[[prev, sid].sort().join('-')];
      if (sid && next) delete lineObj.bends[[sid, next].sort().join('-')];
    }
    return { a: (sid === anchorA) ? (prev || nodes[0]) : anchorA, b: (sid === anchorB) ? (next || nodes[nodes.length-1]) : anchorB, changed: true };
  } else {
    let aIdx = nodes.indexOf(anchorA), bIdx = nodes.indexOf(anchorB);
    if(aIdx === -1 || bIdx === -1) { const hit = findNearestLinkOnLine(lineObj.id, mousePos); aIdx = hit.i; bIdx = hit.i + 1; anchorA = nodes[aIdx]; anchorB = nodes[bIdx]; }
    const insertPos = Math.max(aIdx, bIdx);
    nodes.splice(insertPos, 0, sid);
    const distA = dist(mousePos, stopById(anchorA)), distB = dist(mousePos, stopById(anchorB));
    return (distA < distB) ? { a: anchorA, b: sid, changed: true } : { a: sid, b: anchorB, changed: true };
  }
}

function cleanUpLine(l){
  if(!l || !l.nodes) return;
  for(let i=l.nodes.length-1; i>0; i--){
    if(l.nodes[i] === l.nodes[i-1]) l.nodes.splice(i, 1);
  }
  if(l.nodes.length < 2) {
    lines = lines.filter(line => line.id !== l.id);
    return;
  }
  if(l.bends){
    const valid = new Set();
    for(let i=0; i<l.nodes.length-1; i++){
      const k = [l.nodes[i], l.nodes[i+1]].sort().join('-');
      valid.add(k);
    }
    for(const k in l.bends){
      if(!valid.has(k)) delete l.bends[k];
    }
  }
}

function ensureSpatialConsistency() {
  let changed = false;
  lines.forEach(l => {
    const newNodes = [l.nodes[0]];
    for (let i = 0; i < l.nodes.length - 1; i++) {
      const a = stopById(l.nodes[i]), b = stopById(l.nodes[i+1]);
      if (!a || !b) continue;
      const bendKey = [a.id, b.id].sort().join('-');
      let influence = (l.bends && l.bends[bendKey]) || { x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
      if (isNaN(influence.x) || isNaN(influence.y)) influence = { x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
      const routePts = densifyRoute(calculateRoute(a, b, influence));
      const candidates = stops.filter(s =>
        s.id !== a.id && s.id !== b.id &&
        !l.nodes.includes(s.id) &&
        routePts.some(p => dist(s, p) < 1.0)
      );
      candidates.sort((s1, s2) => dist(a, s1) - dist(a, s2));
      candidates.forEach(c => newNodes.push(c.id));
      newNodes.push(b.id);
      if (candidates.length > 0) changed = true;
    }
    if (newNodes.length !== l.nodes.length) { l.nodes = newNodes; changed = true; }
  });
  if (changed) render.refresh();
}

function buildLinePath(lineObj, nodeIds, corridorsObj){
  if(!nodeIds || nodeIds.length < 2) return [];
  const basePts = [];
  for(let i=0;i<nodeIds.length-1;i++){
    const a = stopById(nodeIds[i]), b = stopById(nodeIds[i+1]);
    if(!a || !b) continue;
    const bendKey = [a.id, b.id].sort().join('-');
    let influence = (lineObj.bends && lineObj.bends[bendKey]) || { x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
    if(gesture.active && gesture.mode === 'segment' && gesture.lid === lineObj.id && gesture.moved){
      if((gesture.anchorA === a.id && gesture.anchorB === b.id) || (gesture.anchorA === b.id && gesture.anchorB === a.id)) influence = appState.mouseRaw;
    }
    const route = calculateRoute(a, b, influence);
    const dense = densifyRoute(route);
    for(const p of dense) if(!basePts.length || dist(basePts[basePts.length-1], p) > 0.5) basePts.push(p);
  }
  if(basePts.length < 2) return [];
  const offs = [], norms = [];
  for(let i=0;i<basePts.length-1;i++){
    offs[i] = (corridorsObj ? getCorridorInfoChunk(lineObj.id, basePts[i], basePts[i+1], corridorsObj.map, corridorsObj.refs).offset : 0);
    norms[i] = getNormal(basePts[i], basePts[i+1]);
  }
  const out = []; const push = (pt) => { if(!out.length || dist(out[out.length-1], pt) > 0.01) out.push(pt); };
  push({ x: basePts[0].x + norms[0].x*offs[0], y: basePts[0].y + norms[0].y*offs[0] });
  for(let i=1;i<basePts.length-1;i++){
    const A = { x: basePts[i].x + norms[i-1].x*offs[i-1], y: basePts[i].y + norms[i-1].y*offs[i-1] },
          B = { x: basePts[i].x + norms[i].x*offs[i], y: basePts[i].y + norms[i].y*offs[i] },
          d1 = { x: basePts[i].x - basePts[i-1].x, y: basePts[i].y - basePts[i-1].y }, 
          d2 = { x: basePts[i+1].x - basePts[i].x, y: basePts[i+1].y - basePts[i].y }, rxs = d1.x*d2.y - d1.y*d2.x;
    if(Math.abs(rxs) > 1e-9){
      const QmP = { x: B.x - A.x, y: B.y - A.y }, t = (QmP.x*d2.y - QmP.y*d2.x) / rxs;
      const I = { x: A.x + t*d1.x, y: A.y + t*d1.y };
      if(dist(I, basePts[i]) <= Math.max(Math.abs(offs[i-1]), Math.abs(offs[i]), LINE_SPACING) * MITER_LIMIT) push(I);
      else { push(A); push(B); }
    } else { push(A); push(B); }
  }
  const lIdx = basePts.length - 1;
  push({ x: basePts[lIdx].x + norms[lIdx-1].x*offs[lIdx-1], y: basePts[lIdx].y + norms[lIdx-1].y*offs[lIdx-1] });
  return compressColinear(out);
}

function findNearestLinkOnLine(lid, pos){
  const l = lineById(lid); if(!l || l.nodes.length<2) return null;
  const pts = buildLinePath(l, l.nodes, buildCorridors());
  let best = { i: 0, d: Infinity };
  for(let k = 0; k < pts.length - 1; k++){
    const d = distPointToSeg(pos, pts[k], pts[k+1]);
    if(d < best.d) best = { i: k, d };
  }
  let nodeIdx = 0, minDist = Infinity;
  for(let i=0; i<l.nodes.length-1; i++){
    const a = stopById(l.nodes[i]), b = stopById(l.nodes[i+1]);
    if(!a || !b) continue;
    const dNode = distPointToSeg(pos, a, b);
    if(dNode < minDist) { minDist = dNode; nodeIdx = i; }
  }
  return { i: nodeIdx, d: best.d };
}

function getLinePathWithExtensions(l, corridorsObj) {
    const pts = buildLinePath(l, l.nodes, corridorsObj);
    if (pts.length < 2) return null;
    const startVec = { x: pts[0].x - pts[1].x, y: pts[0].y - pts[1].y };
    const startLen = Math.hypot(startVec.x, startVec.y) || 1;
    const startDir = { x: startVec.x/startLen, y: startVec.y/startLen };
    const endIdx = pts.length - 1;
    const endVec = { x: pts[endIdx].x - pts[endIdx-1].x, y: pts[endIdx].y - pts[endIdx-1].y };
    const endLen = Math.hypot(endVec.x, endVec.y) || 1;
    const endDir = { x: endVec.x/endLen, y: endVec.y/endLen };
    const extLen = GRID * 0.7; 
    const pStartExt = { x: pts[0].x + startDir.x * extLen, y: pts[0].y + startDir.y * extLen };
    const pEndExt = { x: pts[endIdx].x + endDir.x * extLen, y: pts[endIdx].y + endDir.y * extLen };
    return { pts, pStartExt, pEndExt, startDir, endDir };
}

/* ========= APP LOGIC ========= */
const app = {
  updateStopName(v) { if(appState.popupStopId) { stopById(appState.popupStopId).name = v; render.renderStops(); } },
  updateStopFont(f, el) { if(appState.popupStopId) { stopById(appState.popupStopId).font = f; document.querySelectorAll('.font-opt').forEach(o => o.classList.remove('active')); el.classList.add('active'); render.renderStops(); } },
  updateStopStyle(s, el) { if(appState.popupStopId) { stopById(appState.popupStopId).style = s; document.querySelectorAll('.style-opt').forEach(o => o.classList.remove('active')); el.classList.add('active'); render.renderStops(); } },
  showStopPopup(sid, sx, sy) {
    const s = stopById(sid); if(!s) return; appState.popupStopId = sid; const p = $('stop-popup'); p.style.display = 'block';
    $('popup-stop-name').value = s.name || ""; document.querySelectorAll('.font-opt, .style-opt').forEach(o => o.classList.remove('active'));
    const font = s.font || 'sans-serif', style = s.style || 'standard';
    document.querySelector(`.style-opt[title="${style==='standard'?'Standard':style==='side-square'?'Side':'Inline'}"]`)?.classList.add('active');
    const stopLines = lines.filter(l => l.nodes.includes(sid));
    $('popup-stop-lines').innerHTML = stopLines.length ? stopLines.map(l => `<span class="line-tag shadow-sm" style="background:${l.color}"></span>`).join('') : '<span class="text-[10px] text-gray-400">No lines</span>';
    const px = Math.min(sx + 15, window.innerWidth - 260), py = Math.min(sy + 15, window.innerHeight - 350); p.style.left = px + 'px'; p.style.top = py + 'px';
  },
  hideStopPopup() { $('stop-popup').style.display = 'none'; appState.popupStopId = null; },
  deleteCurrentStop() { if(appState.popupStopId){ const id = appState.popupStopId; lines.forEach(l => l.nodes = l.nodes.filter(n => n !== id)); lines = lines.filter(l => l.nodes.length >= 2); stops = stops.filter(st => st.id !== id); this.hideStopPopup(); render.refresh(); } },
  
  selectLine(id, focusInput = false) {
    appState.selectedLineId = id;
    render.drawMap();
    render.drawUI();
    if (focusInput) {
        setTimeout(() => {
            const input = document.querySelector(`.line-card.active input[type="text"]`);
            if (input) input.focus();
        }, 10);
    }
  },
  updateLineName(id, val) {
    const l = lineById(id);
    if(l) l.name = val;
  },
  updateLineColor(id, val) {
    const l = lineById(id);
    if(l) { l.color = val; render.drawMap(); }
  }
};

/* ========= RENDER ========= */
const render = {
  refresh(){ this.drawMap(); }, 

  drawMap(){ 
      this.renderLines(); 
      this.renderStops(); 
      this.renderHandles(); 
      this.renderGhost(); 
  },

  drawUI(){
    const panel = $('ui-panel');
    panel.innerHTML = lines.map((l,i) => {
      const isSel = appState.selectedLineId === l.id;
      const name = l.name || `Line ${i+1}`;
      if(isSel){
        return `
        <div class="line-card active flex items-center p-2 rounded-xl gap-3 bg-white shadow-lg transition-all border border-blue-500">
          <div class="relative w-6 h-6 flex-shrink-0">
             <div class="absolute inset-0 rounded-lg shadow-inner ring-1 ring-black/10 transition-colors" style="background:${l.color}"></div>
             <input type="color" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer" value="${l.color}" oninput="app.updateLineColor('${l.id}', this.value)">
          </div>
          <input type="text" class="flex-1 font-bold text-sm text-gray-800 bg-transparent border-none focus:ring-0 p-0 m-0" value="${name}" oninput="app.updateLineName('${l.id}', this.value)" placeholder="Line Name">
        </div>`;
      } else {
        return `
        <div class="line-card flex items-center p-2 rounded-xl gap-3 cursor-pointer bg-white border border-gray-100 hover:border-gray-300 hover:shadow-md transition-all" onclick="app.selectLine('${l.id}', true)">
          <div class="w-6 h-6 rounded-lg shadow-inner ring-1 ring-black/5" style="background:${l.color}"></div>
          <span class="text-sm font-bold text-gray-700 truncate select-none flex-1">${name}</span>
        </div>`;
      }
    }).join('');
  },

  renderLines(){
    const layer = $('lines-layer'), edit = $('edit-layer'), drawing = gesture.active && gesture.lid && (gesture.mode === 'extend' || gesture.mode === 'newLine'), corridorsObj = buildCorridors();
    layer.innerHTML = ''; edit.innerHTML = '';
    const activeLid = gesture.lid || appState.selectedLineId;

    const drawLineWithExtensions = (l, isGhost) => {
        const nodesToUse = (isGhost && gesture.mode === 'newLine' && gesture.liveNodes.length) ? gesture.liveNodes : l.nodes;
        const pts = buildLinePath(l, nodesToUse, corridorsObj);
        if (pts.length < 2) return;
        const startVec = { x: pts[0].x - pts[1].x, y: pts[0].y - pts[1].y };
        const startLen = Math.hypot(startVec.x, startVec.y) || 1;
        const startDir = { x: startVec.x/startLen, y: startVec.y/startLen };
        const endIdx = pts.length - 1;
        const endVec = { x: pts[endIdx].x - pts[endIdx-1].x, y: pts[endIdx].y - pts[endIdx-1].y };
        const endLen = Math.hypot(endVec.x, endVec.y) || 1;
        const endDir = { x: endVec.x/endLen, y: endVec.y/endLen };
        const extLen = GRID * 0.7; 
        const pStartExt = { x: pts[0].x + startDir.x * extLen, y: pts[0].y + startDir.y * extLen };
        const pEndExt = { x: pts[endIdx].x + endDir.x * extLen, y: pts[endIdx].y + endDir.y * extLen };
        const createTBar = (pt, dir, className) => {
            const barW = 20; 
            const perp = { x: -dir.y, y: dir.x };
            const p1 = { x: pt.x + perp.x * barW/2, y: pt.y + perp.y * barW/2 };
            const p2 = { x: pt.x - perp.x * barW/2, y: pt.y - perp.y * barW/2 };
            const line = document.createElementNS("http://www.w3.org/2000/svg","line");
            attr(line, { x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y, stroke: l.color, "stroke-width": LINE_WIDTH, "stroke-linecap": "round", class: className + " path" });
            return line;
        };
        const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
        group.classList.add('line-group');
        if(isGhost) group.classList.add('dim');
        else if(activeLid && activeLid !== l.id) group.classList.add('dimmed');
        else if(gesture.active && gesture.mode === 'segment' && gesture.lid === l.id) group.classList.add('editing-focus');
        const allPts = [pStartExt, ...pts, pEndExt];
        const pl = document.createElementNS("http://www.w3.org/2000/svg","polyline");
        pl.classList.add('path');
        attr(pl,{ points: pointsToAttr(allPts), stroke: l.color, 'stroke-width': LINE_WIDTH, 'data-lid': l.id });
        group.appendChild(pl);
        const tStart = createTBar(pStartExt, startDir, 'line-tbar');
        const tEnd = createTBar(pEndExt, endDir, 'line-tbar');
        group.appendChild(tStart);
        group.appendChild(tEnd);
        const container = isGhost ? edit : layer;
        container.appendChild(group);
    };
    for(const l of lines){
      if(drawing && l.id === gesture.lid) continue;
      drawLineWithExtensions(l, false);
    }
  },

  renderStops(){
    const layer = $('stops-layer'); layer.innerHTML = '';
    const corridorsObj = buildCorridors();
    const editedLine = (gesture.active && gesture.lid) ? lineById(gesture.lid) : (appState.selectedLineId ? lineById(appState.selectedLineId) : null);
    const editedNodes = editedLine ? new Set(editedLine.nodes) : new Set();
    const activeNodes = (gesture.active && gesture.mode !== 'segment') ? new Set(gesture.liveNodes) : new Set();
    
    stops.forEach(s => {
      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      g.id = s.id; g.classList.add('stop');
      if(activeNodes.has(s.id)) g.classList.add('onSel');
      if(gesture.hoverStopId === s.id) g.classList.add('hover');
      
      const ring = document.createElementNS("http://www.w3.org/2000/svg","circle");
      ring.classList.add('stop-ring'); attr(ring,{cx:s.x, cy:s.y, r:18});
      if (editedNodes.has(s.id) && !gesture.touchedStops.has(s.id)) { g.classList.add('in-edited-line'); ring.style.stroke = editedLine.color; }
      g.appendChild(ring);
      
      const style = s.style || 'standard', stopLines = lines.filter(l => l.nodes.includes(s.id));
      
      if((style === 'side-square' || style === 'inline-dot') && stopLines.length > 0) {
        stopLines.forEach(l => {
            const idx = l.nodes.indexOf(s.id);
            const pN = stopById(l.nodes[idx+1]);
            const pP = stopById(l.nodes[idx-1]);
            const neighbor = pN || pP;
            if(!neighbor) return;
            
            // Calculate direction to closest grid adjacent point
            const dx = neighbor.x - s.x, dy = neighbor.y - s.y, dlen = Math.hypot(dx,dy)||1;
            const pAdj = { x: s.x + (dx/dlen)*GRID, y: s.y + (dy/dlen)*GRID };
            
            const info = getCorridorInfoChunk(l.id, s, pAdj, corridorsObj.map, corridorsObj.refs);
            const n = getNormal(s, pAdj);
            
            const centerX = s.x + n.x * info.offset;
            const centerY = s.y + n.y * info.offset;

            if (style === 'inline-dot') {
                const dot = document.createElementNS("http://www.w3.org/2000/svg","circle");
                attr(dot, { cx: centerX, cy: centerY, r: 4.5, class: 'stop-inline-dot' });
                g.appendChild(dot);
            } else {
                const shape = document.createElementNS("http://www.w3.org/2000/svg","rect");
                attr(shape, { 
                    x: centerX + n.x*12 - 6, 
                    y: centerY + n.y*12 - 6, 
                    width: 12, height: 12, rx: 2, 
                    fill: l.color, 
                    class: 'stop-side-square' 
                });
                g.appendChild(shape);
            }
        });
      } else if(style === 'standard' || stopLines.length === 0) {
        const shape = document.createElementNS("http://www.w3.org/2000/svg","circle"); 
        attr(shape,{cx:s.x, cy:s.y, r:13.5, class: 'stop-shape'}); 
        g.appendChild(shape);
        if(style === 'inline-dot' && stopLines.length === 0) {
            const dot = document.createElementNS("http://www.w3.org/2000/svg","circle");
            attr(dot, { cx: s.x, cy: s.y, r: 4, class: 'stop-orphan-dot' });
            g.appendChild(dot);
        }
      }

      const hit = document.createElementNS("http://www.w3.org/2000/svg","circle"); attr(hit,{cx:s.x, cy:s.y, r:22, fill:"transparent"}); g.appendChild(hit);
      if (s.name) {
        const txt = document.createElementNS("http://www.w3.org/2000/svg","text"); txt.classList.add('stop-label'); txt.textContent = s.name;
        const f = s.font || 'sans-serif'; if (f === 'serif') txt.style.fontFamily = 'serif'; else if (f === 'monospace') txt.style.fontFamily = 'monospace'; else if (f === 'bold') txt.style.fontWeight = '800'; else if (f === 'italic') txt.style.fontStyle = 'italic';
        attr(txt, { x: s.x + 20, y: s.y + 6 }); g.appendChild(txt);
      }
      layer.appendChild(g);
    });
  },

  renderHandles(){
    const layer = $('handles-layer'); layer.innerHTML = '';
  },

  renderGhost(){
    const g = $('ghost'), sh = $('ghostShadow'); if(!gesture.active || gesture.mode === 'segment' || !gesture.liveNodes.length){ g.style.display = sh.style.display = 'none'; return; }
    const color = gesture.lid ? (lineById(gesture.lid)?.color || colors[0]) : (colors.find(c => !new Set(lines.map(l=>l.color)).has(c)) || colors[0]);
    $('app-svg').style.setProperty('--lc', color);
    let pts = buildLinePath({bends:{}}, gesture.liveNodes, null);
    if(gesture.tempPoint){
      const last = stopById(gesture.liveNodes[gesture.liveNodes.length-1]);
      if (last) {
        const route = calculateRoute(last, gesture.tempPoint, appState.mouseRaw);
        route.shift(); pts = pts.concat(route);
      }
    }
    const val = pointsToAttr(pts); g.style.display = sh.style.display = 'block'; g.setAttribute('points', val); sh.setAttribute('points', val);
  }
};

/* ========= INTERACTION ========= */
$('app-svg').addEventListener('pointerdown', e => {
  if (e.target.closest('#stop-popup')) return;
  app.hideStopPopup();
  if (e.button === 1 || appState.space) {
    appState.panStart = { x: e.clientX, y: e.clientY, vx: view.x, vy: view.y };
    return;
  }

  const pos = getMousePos(e);
  const hStop = getStopNear(pos, 32); 
  const hPath = e.target.closest('.path');

  Object.assign(gesture, {
    active: true, moved: false, startTime: Date.now(),
    startPt: pos, startScreen: { x: e.clientX, y: e.clientY },
    lid: null, liveNodes: [], tempPoint: null,
    anchorA: null, anchorB: null, lastAppliedHover: null,
    initialTargetStop: hStop ? hStop.id : null,
    prevRaw: pos, touchLatch: new Set(), touchedStops: new Set()
  });

  let foundExt = false;
  for (const l of lines) {
    const info = getLinePathWithExtensions(l, buildCorridors());
    if (info) {
      const DIST_T_BAR_TIP = 24; 
      const DIST_TO_NODES = 15;
      const distToStartTip = dist(pos, info.pStartExt);
      const distToEndTip = dist(pos, info.pEndExt);
      const sNode = stopById(l.nodes[0]);
      const eNode = stopById(l.nodes[l.nodes.length-1]);
      const distToSNode = sNode ? dist(pos, sNode) : Infinity;
      const distToENode = eNode ? dist(pos, eNode) : Infinity;

      if (distToStartTip < DIST_T_BAR_TIP && distToSNode > DIST_TO_NODES) {
        gesture.mode = 'extend'; gesture.lid = l.id; app.selectLine(l.id, false);
        gesture.liveNodes = [...l.nodes].reverse();
        foundExt = true; break;
      }
      if (distToEndTip < DIST_T_BAR_TIP && distToENode > DIST_TO_NODES) {
        gesture.mode = 'extend'; gesture.lid = l.id; app.selectLine(l.id, false);
        gesture.liveNodes = [...l.nodes];
        foundExt = true; break;
      }
    }
  }

  if (foundExt) { render.drawMap(); render.drawUI(); return; }
  if (hStop) { gesture.mode = 'newLine'; gesture.liveNodes = [hStop.id]; render.drawMap(); render.drawUI(); return; }
  if (hPath) {
    const lid = hPath.dataset.lid;
    const hit = findNearestLinkOnLine(lid, pos);
    app.selectLine(lid, false);
    gesture.lid = lid;
    if (hit) {
      gesture.mode = 'segment';
      const l = lineById(lid);
      gesture.anchorA = l.nodes[hit.i];
      gesture.anchorB = l.nodes[hit.i + 1];
    }
    render.drawMap(); render.drawUI(); return;
  }

  gesture.mode = 'tapEmpty';
  appState.panStart = { x: e.clientX, y: e.clientY, vx: view.x, vy: view.y };
  render.drawMap();
});

$('app-svg').addEventListener('pointermove', e => {
  const pos = getMousePos(e); appState.mouseRaw = pos;
  if(gesture.active && !gesture.moved && Math.hypot(e.clientX - gesture.startScreen.x, e.clientY - gesture.startScreen.y) > MOVE_THRESHOLD) gesture.moved = true;
  if(appState.panStart){ if (gesture.moved) { view.x = appState.panStart.vx - (e.clientX - appState.panStart.x)*(view.w/window.innerWidth); view.y = appState.panStart.vy - (e.clientY - appState.panStart.y)*(view.h/window.innerHeight); setView(); $('app-svg').classList.add('panning'); } return; }
  if(!gesture.active) return;
  const curr = pos, corridorsObj = buildCorridors(), h = getStopNear(curr, 36);
  gesture.hoverStopId = h ? h.id : null;
  if(gesture.mode === 'segment' && gesture.lid){
    const l = lineById(gesture.lid); if(!l) return;
    if(gesture.touchLatch.size){ for(const sid of gesture.touchLatch) if(minDistToStopVisual(curr, stopById(sid), corridorsObj) > 46) gesture.touchLatch.delete(sid); }
    if(h && !gesture.touchLatch.has(h.id)){
      const inLine = l.nodes.includes(h.id);
      const distToStop = minDistToStopVisual(curr, h, corridorsObj);
      const threshold = inLine ? 10 : 36;
      if (distToStop <= threshold) {
        const result = toggleStopOnLine(l, h.id, gesture.anchorA, gesture.anchorB, curr);
        gesture.anchorA = result.a; gesture.anchorB = result.b;
        if(inLine && result.changed) gesture.touchedStops.add(h.id); 
        gesture.touchLatch.add(h.id); pulseStop(h.id);
      }
    } else if(!h && gesture.moved){
      const bendKey = [gesture.anchorA, gesture.anchorB].sort().join('-');
      if(!l.bends) l.bends = {}; l.bends[bendKey] = { x: curr.x, y: curr.y };
    }
    render.drawMap(); return;
  }
  if(gesture.mode==='extend' || gesture.mode==='newLine'){
    if(h){
      const idx = gesture.liveNodes.indexOf(h.id);
      if(idx === -1) { gesture.liveNodes.push(h.id); pulseStop(h.id); }
      else if(idx < gesture.liveNodes.length - 1) { gesture.liveNodes = gesture.liveNodes.slice(0, idx+1); pulseStop(h.id); }
      gesture.tempPoint = null;
    } else if(gesture.liveNodes.length){
      const ln = stopById(gesture.liveNodes[gesture.liveNodes.length-1]), dx=pos.x-ln.x, dy=pos.y-ln.y, a=Math.round(Math.atan2(dy,dx)/(Math.PI/4))*(Math.PI/4), d=dist(pos, ln);
      gesture.tempPoint = { x: ln.x+Math.cos(a)*d, y: ln.y+Math.sin(a)*d };
    }
    render.drawMap();
  }
});

$('app-svg').addEventListener('pointerup', e => {
  const dur = Date.now() - gesture.startTime; $('app-svg').classList.remove('panning');
  if(!gesture.active && !appState.panStart) return;
  const wasEditing = (gesture.mode === 'segment' || gesture.mode === 'extend' || gesture.mode === 'newLine');
  const wasTapEmpty = (gesture.mode === 'tapEmpty');
  if (gesture.initialTargetStop && !gesture.moved && dur < TAP_THRESHOLD) { app.showStopPopup(gesture.initialTargetStop, e.clientX, e.clientY); }
  else if(wasTapEmpty && !gesture.moved && dur < TAP_THRESHOLD){
    if(appState.selectedLineId){ appState.selectedLineId = null; render.drawUI(); }
    else {
      const sPos = { x: snap(getMousePos(e).x), y: snap(getMousePos(e).y) };
      if(!getStopNear(sPos, 20)){ stops.push({ id: 's'+Date.now(), ...sPos, name: "", font: "sans-serif", style: "standard" }); pulseStop(stops[stops.length-1].id); }
    }
  } else if(gesture.mode==='newLine' && gesture.liveNodes.length >= 2){
    const newLine = { id: 'l'+Date.now(), name: `Line ${lines.length+1}`, color: colors.find(c => !new Set(lines.map(l=>l.color)).has(c)) || colors[0], nodes: [...gesture.liveNodes], bends: {} };
    lines.push(newLine); render.drawUI();
  } else if(gesture.mode==='extend' && gesture.lid){
    const l = lineById(gesture.lid); if(l){ 
        if(gesture.liveNodes.length >= 2) l.nodes = (gesture.liveNodes[0] === l.nodes[0]) ? [...gesture.liveNodes] : [...gesture.liveNodes].reverse(); 
        else { lines = lines.filter(x => x.id !== l.id); render.drawUI(); }
    }
  }
  if (gesture.lid) { const l = lineById(gesture.lid); if (l) cleanUpLine(l); }
  ensureSpatialConsistency();
  if ((gesture.moved && wasEditing) || (wasTapEmpty && !gesture.moved)) { appState.selectedLineId = null; render.drawUI(); }
  gesture.active = false; gesture.mode = null; gesture.lid = null; gesture.hoverStopId = null; 
  gesture.touchLatch = new Set(); gesture.touchedStops = new Set(); appState.panStart = null; 
  render.drawMap();
});

const io = {
  export(){
    const data = btoa(unescape(encodeURIComponent(JSON.stringify({stops, lines, corridorOrders}))));
    const a = document.createElement('a');
    a.href = URL.createObjectURL(new Blob([$('app-svg').outerHTML.replace('<svg', `<svg xmlns="http://www.w3.org/2000/svg" data-metro="${data}"`)], {type:'image/svg+xml'}));
    a.download='metro.svg'; a.click();
  },
  import(inp){
    const r = new FileReader(); r.onload = e => {
      try {
        const parser = new DOMParser();
        const doc = parser.parseFromString(e.target.result, "image/svg+xml");
        const svg = doc.querySelector('svg');
        if(svg && svg.dataset.metro){
            const d = JSON.parse(decodeURIComponent(escape(atob(svg.dataset.metro))));
            stops=d.stops||[]; lines=d.lines||[]; corridorOrders=d.corridorOrders||{}; 
            render.drawMap(); render.drawUI();
        }
      } catch(err) { console.error(err); alert("Error importing file"); }
    }; if(inp.files[0]) r.readAsText(inp.files[0]);
  }
};
window.addEventListener('keydown', e => e.code==='Space'&&(appState.space=true));
window.addEventListener('keyup', e => e.code==='Space'&&(appState.space=false));
window.addEventListener('resize', setView);
$('app-svg').addEventListener('wheel', setViewOnWheel, {passive:false});
render.drawUI(); setView(); render.drawMap();
</script>
</body>
</html>
