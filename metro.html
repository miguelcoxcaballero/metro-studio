<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Metro Studio Lite</title>
<script src="https://cdn.tailwindcss.com"></script>

<style>
  :root{
    --bg0:#f3f4f7;
    --bg1:#eceef3;
    --ink:#202124;
    --soft:#6b7280;
    --lc:#1a73e8;
  }

  html,body{
    margin:0; width:100%; height:100%;
    overflow:hidden; user-select:none;
    font-family:"Google Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    background:
      radial-gradient(1200px 700px at 50% 45%, rgba(255,255,255,0.95), rgba(245,246,249,0.75) 55%, rgba(232,234,238,0.95) 100%),
      linear-gradient(180deg, var(--bg0), var(--bg1));
  }

  #app-svg{
    display:block; width:100%; height:100%;
    cursor:crosshair;
    touch-action:none;
  }

  .path{
    fill:none;
    stroke-linecap:round;
    stroke-linejoin:round;
    pointer-events:stroke;
    cursor:pointer;
    transition: opacity .15s ease, stroke-width .15s ease;
  }
  .path:hover{ stroke-width: 12.5px !important; }
  .path.sel{ stroke-width: 12px !important; }
  .path.dim{ opacity:.15; }
  .path.reordering{ stroke-width: 13px !important; filter: drop-shadow(0 0 6px currentColor); }

  #ghostShadow{ pointer-events:none; opacity:.15; }
  #ghost{
    pointer-events:none;
    opacity:.9;
    filter: drop-shadow(0 2px 3px rgba(0,0,0,.1));
  }

  .stop-shape{
    fill:#fff;
    stroke:var(--ink);
    stroke-width:3;
    vector-effect: non-scaling-stroke;
    transition: transform .12s ease;
    transform-box: fill-box;
    transform-origin:center;
  }
  .stop-ring{
    fill:none;
    stroke: var(--lc);
    stroke-width: 6;
    opacity: 0;
    vector-effect: non-scaling-stroke;
    transition: opacity .12s ease;
  }
  .stop.hover .stop-shape{ transform: scale(1.15); }
  .stop.onSel .stop-ring{ opacity: 0.8; }
  .stop.pulse .stop-shape{ animation: pulseAnim .25s cubic-bezier(.2,.9,.2,1.1); }

  @keyframes pulseAnim{
    0%{ transform:scale(1); }
    50%{ transform:scale(1.3); }
    100%{ transform:scale(1); }
  }

  .handle{ cursor: grab; }
  .handle:active{ cursor: grabbing; }

  header, #ui-panel{
    background: rgba(255,255,255,0.85) !important;
    backdrop-filter: blur(10px);
  }

  .corridor-hint{
    position: fixed;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 13px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
  }
  .corridor-hint.visible{ opacity: 1; }
</style>
</head>

<body>
  <header class="absolute top-4 left-4 right-4 h-14 rounded-2xl flex items-center justify-between px-6 shadow-sm z-50 border border-gray-200">
    <div class="flex items-center gap-2 text-gray-800 font-medium">
      <div class="p-1.5 bg-blue-50 rounded text-blue-600">
        <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.52 2 12 2zm0 18c-4.4 0-8-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8zm-5.5-2.5l7.5-3.2-7.5-3.2V17.5z"/></svg>
      </div>
      Metro Studio Lite
    </div>
    <div class="flex gap-2">
      <button onclick="$('inp').click()" class="px-4 py-2 hover:bg-gray-100 rounded-xl text-sm font-medium transition-colors">Importar</button>
      <input id="inp" type="file" hidden onchange="io.import(this)">
      <button onclick="io.export()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-xl text-sm font-medium shadow-sm transition-all">Exportar</button>
    </div>
  </header>

  <div id="ui-panel" class="absolute bottom-6 left-6 w-64 max-h-[40vh] overflow-y-auto rounded-2xl p-2 shadow-xl border border-gray-200 z-40 flex flex-col-reverse gap-2 empty:hidden"></div>

  <div id="corridor-hint" class="corridor-hint">Arrastra lateralmente para reordenar líneas en el corredor</div>

  <svg id="app-svg" preserveAspectRatio="xMidYMid slice">
    <defs>
      <pattern id="grid-pattern" x="-20" y="-20" width="40" height="40" patternUnits="userSpaceOnUse">
        <circle cx="20" cy="20" r="1.5" fill="#cbd5e1"/>
      </pattern>
      <radialGradient id="vignette" cx="50%" cy="45%" r="70%">
        <stop offset="0%" stop-color="rgba(0,0,0,0)" /><stop offset="100%" stop-color="rgba(0,0,0,0.05)" />
      </radialGradient>
    </defs>
    <rect x="-10000" y="-10000" width="20000" height="20000" fill="url(#grid-pattern)"></rect>
    <rect x="-10000" y="-10000" width="20000" height="20000" fill="url(#vignette)" pointer-events="none"></rect>

    <g id="lines-layer"></g>
    <g id="edit-layer"></g>

    <polyline id="ghostShadow" fill="none" stroke="#000" stroke-width="16" stroke-linecap="round" stroke-linejoin="round" style="display:none"></polyline>
    <polyline id="ghost" fill="none" stroke="var(--lc)" stroke-width="11" stroke-linecap="round" stroke-linejoin="round" style="display:none"></polyline>

    <g id="handles-layer"></g>
    <g id="stops-layer"></g>
  </svg>

<script>
/* ========= CONFIGURACIÓN Y ESTADO ========= */
const GRID = 40;
const LINE_WIDTH = 10;
const LINE_SPACING = 12;
const TRANSITION_DIST = 8;

let stops = [];
let lines = [];
let corridorOrders = {};

const colors = ['#EA4335','#4285F4','#34A853','#F4C20D','#AB47BC','#FF6D00'];
let view = { x: 500, y: 375, w: 1000, h: 750 };

const appState = { selectedLineId: null, space: false, panStart: null, mouseRaw: {x:0, y:0} };

const gesture = {
  active: false,
  mode: null,
  moved: false,
  startPt: null,
  lid: null,
  liveNodes: [],
  hoverStopId: null,
  tempPoint: null,
  anchorA: null,
  anchorB: null,
  lastAppliedHover: null,
  originalLineNodes: [],
  corridorKey: null,
  corridorDragMode: null,
  corridorOriginalOrder: []
};

/* ========= UTILIDADES BÁSICAS ========= */
const $ = id => document.getElementById(id);
const attr = (el, a) => { for (const k in a) el.setAttribute(k, a[k]); };
const dist = (a,b) => Math.hypot(a.x-b.x, a.y-b.y);
const snap = v => Math.round(v / GRID) * GRID;
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const snapLen = v => Math.round(v / GRID) * GRID;

function getMousePos(evt){
  const svg = $('app-svg'), p = svg.createSVGPoint();
  p.x = evt.clientX; p.y = evt.clientY;
  return p.matrixTransform(svg.getScreenCTM().inverse());
}

function stopById(id){ return stops.find(s=>s.id===id); }
function lineById(id){ return lines.find(l=>l.id===id); }

function getStopNear(pos, d=26){
  let best=null, bd=Infinity;
  for(const s of stops){
    const dd = Math.hypot(s.x-pos.x, s.y-pos.y);
    if(dd<d && dd<bd){ bd=dd; best=s; }
  }
  return best;
}

function pulseStop(id){
  const g = $(id); if(!g) return;
  g.classList.remove('pulse'); void g.offsetWidth; g.classList.add('pulse');
}

function distPointToSeg(p,a,b){
  const vx=b.x-a.x, vy=b.y-a.y, wx=p.x-a.x, wy=p.y-a.y;
  const vv = vx*vx+vy*vy || 1;
  let t = Math.max(0, Math.min(1,(wx*vx+wy*vy)/vv));
  return Math.hypot(p.x-(a.x+t*vx), p.y-(a.y+t*vy));
}

function getNormal(p1, p2) {
  const dx = p2.x - p1.x, dy = p2.y - p1.y;
  const len = Math.hypot(dx, dy) || 1;
  return { x: -dy / len, y: dx / len };
}

function getTangent(p1, p2) {
  const dx = p2.x - p1.x, dy = p2.y - p1.y;
  const len = Math.hypot(dx, dy) || 1;
  return { x: dx / len, y: dy / len };
}

function pointsToAttr(pts){ return pts.map(p => `${p.x},${p.y}`).join(' '); }

function setView(){
  view.h = view.w * (window.innerHeight / window.innerWidth);
  attr($('app-svg'), { viewBox: `${view.x} ${view.y} ${view.w} ${view.h}` });
}

/* ========= LÓGICA DE CORREDORES ========= */
function getCorridorKey(s1, s2) {
  return [s1, s2].sort().join('|');
}

function buildCorridors() {
  const map = {};
  for (const line of lines) {
    if (!line.nodes) continue;
    for (let i = 0; i < line.nodes.length - 1; i++) {
      const key = getCorridorKey(line.nodes[i], line.nodes[i + 1]);
      if (!map[key]) map[key] = [];
      if (!map[key].includes(line.id)) map[key].push(line.id);
    }
  }
  for (const key in map) {
    if (corridorOrders[key]) {
      const saved = corridorOrders[key].filter(id => map[key].includes(id));
      const extra = map[key].filter(id => !saved.includes(id));
      map[key] = [...saved, ...extra];
    }
  }
  return map;
}

function getCorridorInfo(lineId, fromStopId, toStopId, corridors) {
  const key = getCorridorKey(fromStopId, toStopId);
  const corridor = corridors[key];
  if (!corridor || corridor.length < 2) return { offset: 0, count: 1, index: 0 };
  const n = corridor.length;
  const idx = corridor.indexOf(lineId);
  if (idx === -1) return { offset: 0, count: 1, index: 0 };
  const offset = (idx - (n - 1) / 2) * LINE_SPACING;
  const [first] = [fromStopId, toStopId].sort();
  const sign = fromStopId === first ? 1 : -1;
  return { offset: offset * sign, count: n, index: idx };
}

/* ========= MOTOR DE RUTAS ========= */

function calculateRoute(p1, p2, influencePt){
  const A = { x: p1.x, y: p1.y };
  const B = { x: p2.x, y: p2.y };
  const dx = B.x - A.x, dy = B.y - A.y;
  const adx = Math.abs(dx), ady = Math.abs(dy);

  if(adx < 0.5 || ady < 0.5) return [A, B];
  if(Math.abs(adx - ady) < 0.5) return [A, B];

  const sx = Math.sign(dx), sy = Math.sign(dy);
  const diag = Math.min(adx, ady);
  const extra = Math.abs(adx - ady);
  const dom = (adx > ady) ? 'x' : 'y';

  let pre = extra / 2;
  if(influencePt){
    if(dom === 'x'){
      const prog = (influencePt.x - A.x) * sx;
      pre = prog - diag / 2;
    } else {
      const prog = (influencePt.y - A.y) * sy;
      pre = prog - diag / 2;
    }
  }
  pre = snapLen(pre);
  pre = clamp(pre, 0, extra);
  const post = extra - pre;

  const pts = [A];
  const pushIfNew = (p) => {
    const last = pts[pts.length-1];
    if(!last || Math.abs(last.x - p.x) > 0.5 || Math.abs(last.y - p.y) > 0.5) pts.push(p);
  };

  if(dom === 'x'){
    const P1 = { x: A.x + sx*pre,      y: A.y };
    const P2 = { x: P1.x + sx*diag,    y: P1.y + sy*diag };
    const P3 = { x: P2.x + sx*post,    y: P2.y };
    pushIfNew(P1); pushIfNew(P2); pushIfNew(P3);
  } else {
    const P1 = { x: A.x,               y: A.y + sy*pre };
    const P2 = { x: P1.x + sx*diag,    y: P1.y + sy*diag };
    const P3 = { x: P2.x,              y: P2.y + sy*post };
    pushIfNew(P1); pushIfNew(P2); pushIfNew(P3);
  }
  pushIfNew(B);
  return pts;
}

function buildLinePath(lineObj, nodeIds, corridors) {
  if (!nodeIds || nodeIds.length < 2) return [];
  if (!lineObj.bends) lineObj.bends = {};
  
  const rawSegments = [];
  for (let i = 0; i < nodeIds.length - 1; i++) {
    const a = stopById(nodeIds[i]), b = stopById(nodeIds[i + 1]);
    if (!a || !b) continue;
    const bendKey = [a.id, b.id].sort().join('-');
    let influence = lineObj.bends[bendKey] || { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
    
    const isEditing = gesture.active && gesture.mode === 'segment' && gesture.corridorDragMode === 'insert' &&
                      gesture.lid === lineObj.id && ((gesture.anchorA === a.id && gesture.anchorB === b.id) || (gesture.anchorA === b.id && gesture.anchorB === a.id));
    if (isEditing && gesture.moved) {
      influence = appState.mouseRaw;
      lineObj.bends[bendKey] = { x: influence.x, y: influence.y };
    }
    
    const pts = calculateRoute(a, b, influence);
    const corrInfo = corridors ? getCorridorInfo(lineObj.id, a.id, b.id, corridors) : { offset: 0 };
    rawSegments.push({ pts, offset: corrInfo.offset });
  }

  const finalPts = [];
  for (let i = 0; i < rawSegments.length; i++) {
    const seg = rawSegments[i];
    const prev = i > 0 ? rawSegments[i-1] : null;
    const next = i < rawSegments.length - 1 ? rawSegments[i+1] : null;
    const pts = seg.pts, off = seg.offset;

    for (let k = 0; k < pts.length; k++) {
      const p = pts[k];
      let resP = { ...p };

      if (k === 0) {
        if (!prev) {
          const n = getNormal(pts[0], pts[1]);
          resP.x += n.x * off; resP.y += n.y * off;
        } else {
          const nPrev = getNormal(prev.pts[prev.pts.length - 2], prev.pts[prev.pts.length - 1]);
          const nCurr = getNormal(pts[0], pts[1]);
          const tPrev = getTangent(prev.pts[prev.pts.length - 2], prev.pts[prev.pts.length - 1]);
          const tCurr = getTangent(pts[0], pts[1]);

          if (Math.abs(prev.offset - off) < 0.1) {
            const dot = nPrev.x * nCurr.x + nPrev.y * nCurr.y;
            const miterScale = 1 / Math.max(0.1, (1 + dot));
            resP.x += (nPrev.x * prev.offset + nCurr.x * off) * miterScale;
            resP.y += (nPrev.y * prev.offset + nCurr.y * off) * miterScale;
          } else {
            finalPts.push({
              x: p.x - tPrev.x * TRANSITION_DIST + nPrev.x * prev.offset,
              y: p.y - tPrev.y * TRANSITION_DIST + nPrev.y * prev.offset
            });
            resP.x += tCurr.x * TRANSITION_DIST + nCurr.x * off;
            resP.y += tCurr.y * TRANSITION_DIST + nCurr.y * off;
          }
        }
      } else if (k === pts.length - 1) {
        if (!next) {
          const n = getNormal(pts[pts.length - 2], pts[pts.length - 1]);
          resP.x += n.x * off; resP.y += n.y * off;
        } else continue;
      } else {
        const nPrev = getNormal(pts[k-1], pts[k]);
        const nNext = getNormal(pts[k], pts[k+1]);
        const dot = nPrev.x * nNext.x + nPrev.y * nNext.y;
        const miterScale = 1 / Math.max(0.1, (1 + dot));
        resP.x += (nPrev.x * off + nNext.x * off) * miterScale;
        resP.y += (nPrev.y * off + nNext.y * off) * miterScale;
      }
      finalPts.push(resP);
    }
  }
  return finalPts;
}

function findNearestLinkOnLine(lid, pos){
  const l = lineById(lid); if(!l || l.nodes.length<2) return null;
  const corridors = buildCorridors();
  const pts = buildLinePath(l, l.nodes, corridors);
  let best = { i: 0, d: Infinity };
  for(let k = 0; k < pts.length - 1; k++){
    const d = distPointToSeg(pos, pts[k], pts[k+1]);
    if(d < best.d) {
      let nodeIdx = 0;
      let minDist = Infinity;
      for(let i=0; i<l.nodes.length-1; i++) {
        const dNode = distPointToSeg(pos, stopById(l.nodes[i]), stopById(l.nodes[i+1]));
        if(dNode < minDist) { minDist = dNode; nodeIdx = i; }
      }
      best = { i: nodeIdx, d };
    }
  }
  return best;
}

function findEndpointAtStop(stopId){
  const list = appState.selectedLineId ? [lineById(appState.selectedLineId), ...lines] : lines;
  for(const l of list){
    if(!l || !l.nodes || l.nodes.length<1) continue;
    if(l.nodes[0] === stopId) return { lid:l.id, end:'start' };
    if(l.nodes[l.nodes.length-1] === stopId) return { lid:l.id, end:'end' };
  }
  return null;
}

/* ========= RENDER ========= */
const render = {
  refresh(){
    this.renderLines();
    this.renderStops();
    this.renderHandles();
    this.renderUI();
    this.renderGhost();
  },

  renderLines(){
    const layer = $('lines-layer'), edit = $('edit-layer');
    layer.innerHTML = ''; edit.innerHTML = '';
    const drawing = gesture.active && gesture.lid && (gesture.mode === 'extend');
    const corridors = buildCorridors();

    for(const l of lines){
      if(l.nodes.length < 2) continue;
      if(drawing && l.id === gesture.lid) continue;
      const pts = buildLinePath(l, l.nodes, corridors);
      if (pts.length < 2) continue;
      const pl = document.createElementNS("http://www.w3.org/2000/svg","polyline");
      pl.classList.add('path');
      if(appState.selectedLineId === l.id) pl.classList.add('sel');
      if(gesture.mode === 'segment' && gesture.corridorDragMode === 'reorder' && gesture.lid === l.id) pl.classList.add('reordering');
      attr(pl,{ points: pointsToAttr(pts), stroke: l.color, 'stroke-width': LINE_WIDTH, 'data-lid': l.id });
      layer.appendChild(pl);
    }

    if(drawing){
      const l = lineById(gesture.lid);
      const pl = document.createElementNS("http://www.w3.org/2000/svg","polyline");
      pl.classList.add('path','dim');
      attr(pl,{ points: pointsToAttr(buildLinePath(l, gesture.originalLineNodes, corridors)), stroke: l.color, 'stroke-width': LINE_WIDTH });
      edit.appendChild(pl);
    }
  },

  renderStops(){
    const layer = $('stops-layer'); layer.innerHTML = '';
    let selNodes = gesture.active && gesture.mode !== 'segment' && gesture.liveNodes?.length 
      ? new Set(gesture.liveNodes) : new Set(lineById(gesture.lid || appState.selectedLineId)?.nodes || []);

    stops.forEach(s => {
      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      g.id = s.id; g.classList.add('stop');
      if(selNodes.has(s.id)) g.classList.add('onSel');
      if(gesture.hoverStopId === s.id) g.classList.add('hover');
      const ring = document.createElementNS("http://www.w3.org/2000/svg","circle");
      ring.classList.add('stop-ring'); attr(ring,{cx:s.x, cy:s.y, r:16});
      const shape = document.createElementNS("http://www.w3.org/2000/svg","circle");
      shape.classList.add('stop-shape'); attr(shape,{cx:s.x, cy:s.y, r:13.5});
      const hit = document.createElementNS("http://www.w3.org/2000/svg","circle");
      attr(hit,{cx:s.x, cy:s.y, r:22, fill:"transparent"});
      g.append(ring, shape, hit); layer.appendChild(g);
    });
  },

  renderHandles(){
    const layer = $('handles-layer'); layer.innerHTML = '';
    const l = lineById(appState.selectedLineId);
    if(!l || l.nodes.length<2 || gesture.active) return;
    const pts = buildLinePath(l, l.nodes, buildCorridors());
    if (pts.length < 2) return;
    const mk = (p, toward, end) => {
      const dx=p.x-toward.x, dy=p.y-toward.y, len=Math.hypot(dx,dy)||1, ux=dx/len, uy=dy/len, px=-uy, py=ux;
      const cx=p.x+ux*12, cy=p.y+uy*12;
      const line = document.createElementNS("http://www.w3.org/2000/svg","line");
      attr(line,{x1:cx+px*12, y1:cy+py*12, x2:cx-px*12, y2:cy-py*12, stroke:l.color, 'stroke-width':10, class:'handle','data-lid':l.id,'data-end':end});
      layer.appendChild(line);
    };
    mk(pts[0], pts[1], 'start'); 
    mk(pts[pts.length-1], pts[pts.length-2], 'end');
  },

  renderUI(){
    $('ui-panel').innerHTML = lines.map((l,i) => `
      <div class="flex items-center p-2 rounded-xl gap-3 cursor-pointer ${appState.selectedLineId===l.id?'bg-blue-50 ring-1 ring-blue-200 shadow-sm' : 'bg-white border border-gray-100'}"
           onclick="appState.selectedLineId='${l.id}';render.refresh()">
        <div class="w-5 h-5 rounded-full" style="background:${l.color}"></div>
        <span class="text-sm font-semibold text-gray-700">Línea ${i+1}</span>
      </div>`).join('');
  },

  renderGhost(){
    const g = $('ghost'), sh = $('ghostShadow');
    if(!gesture.active || gesture.mode === 'segment' || !gesture.liveNodes.length){
      g.style.display = sh.style.display = 'none'; return;
    }
    const color = gesture.lid ? (lineById(gesture.lid)?.color || colors[0]) : colorForNew();
    $('app-svg').style.setProperty('--lc', color);
    let pts = buildLinePath({bends:{}}, gesture.liveNodes, null);
    if(gesture.tempPoint){
      const last = stopById(gesture.liveNodes[gesture.liveNodes.length-1]);
      const route = calculateRoute(last, gesture.tempPoint, appState.mouseRaw);
      route.shift(); pts = pts.concat(route);
    }
    const attrVal = pointsToAttr(pts);
    g.style.display = sh.style.display = 'block'; g.setAttribute('points', attrVal); sh.setAttribute('points', attrVal);
  }
};

/* ========= INTERACCIÓN ========= */
function setViewOnWheel(e){
  e.preventDefault();
  const nw = view.w * Math.pow(1.1, e.deltaY > 0 ? 1 : -1);
  if(nw<100 || nw>10000) return;
  const mx=e.offsetX/window.innerWidth, my=e.offsetY/window.innerHeight;
  view.x += mx*(view.w-nw); view.y += my*(view.h-(nw*(window.innerHeight / window.innerWidth)));
  view.w = nw; setView();
}

function colorForNew(){
  const used = new Set(lines.map(l=>l.color));
  return colors.find(c=>!used.has(c)) || colors[lines.length%colors.length];
}

function showCorridorHint(show) {
  const hint = $('corridor-hint');
  if (show) hint.classList.add('visible');
  else hint.classList.remove('visible');
}

function toggleStationOnLineDuringInsert(l, sid){
  if(!l || !sid || sid === gesture.anchorA || sid === gesture.anchorB) return;
  const already = l.nodes.indexOf(sid);
  if(already !== -1){
    l.nodes = l.nodes.filter(x => x !== sid);
    if(l.nodes.length < 2) lines = lines.filter(x => x.id !== l.id);
    pulseStop(sid);
  } else {
    const insIdx = l.nodes.indexOf(gesture.anchorB);
    l.nodes.splice(insIdx, 0, sid);
    pulseStop(sid);
  }
}

$('app-svg').addEventListener('pointerdown', e => {
  if(e.button===1 || appState.space){ appState.panStart={x:e.clientX, y:e.clientY, vx:view.x, vy:view.y}; return; }
  const pos = getMousePos(e), hStop = getStopNear(pos), hPath = e.target.closest('.path'), hCap = e.target.closest('.handle');
  Object.assign(gesture, { active: true, moved: false, startPt: pos, lid: null, liveNodes: [], tempPoint: null, anchorA: null, anchorB: null, lastAppliedHover: null, originalLineNodes: [], corridorKey: null, corridorDragMode: null, corridorOriginalOrder: [] });

  if(hCap){
    const l = lineById(hCap.dataset.lid);
    gesture.mode='extend'; gesture.lid=l.id; appState.selectedLineId = l.id;
    gesture.liveNodes = hCap.dataset.end==='start' ? [...l.nodes].reverse() : [...l.nodes];
    gesture.originalLineNodes = [...l.nodes];
  } else if(hStop){
    const ep = findEndpointAtStop(hStop.id);
    if(ep){
      gesture.mode='extend'; gesture.lid=ep.lid; appState.selectedLineId = ep.lid;
      const l = lineById(ep.lid); gesture.liveNodes = ep.end==='start' ? [...l.nodes].reverse() : [...l.nodes];
      gesture.originalLineNodes = [...l.nodes];
    } else { gesture.mode='newLine'; gesture.liveNodes = [hStop.id]; }
  } else if(hPath){
    const lid = hPath.dataset.lid;
    const hit = findNearestLinkOnLine(lid, pos);
    if(hit && hit.d <= 22){
      appState.selectedLineId = lid; gesture.mode = 'segment'; gesture.lid = lid;
      const l = lineById(lid); gesture.anchorA = l.nodes[hit.i]; gesture.anchorB = l.nodes[hit.i + 1];
      gesture.originalLineNodes = [...l.nodes];
      gesture.corridorKey = getCorridorKey(gesture.anchorA, gesture.anchorB);
      const corridors = buildCorridors();
      if (corridors[gesture.corridorKey]?.length > 1) { gesture.corridorOriginalOrder = [...corridors[gesture.corridorKey]]; showCorridorHint(true); }
    } else { appState.selectedLineId = lid; gesture.mode = 'select'; gesture.active = false; }
  } else { gesture.mode='tapEmpty'; appState.selectedLineId = null; }
  render.refresh();
});

$('app-svg').addEventListener('pointermove', e => {
  const pos = getMousePos(e); appState.mouseRaw = pos;
  if(appState.panStart){
    view.x = appState.panStart.vx - (e.clientX - appState.panStart.x)*(view.w/window.innerWidth);
    view.y = appState.panStart.vy - (e.clientY - appState.panStart.y)*(view.h/window.innerHeight);
    setView(); return;
  }
  if(!gesture.active) return;
  if(!gesture.moved && dist(pos, gesture.startPt)>6) gesture.moved=true;
  const h = getStopNear(pos, 32); gesture.hoverStopId = h ? h.id : null;

  if(gesture.mode === 'segment' && gesture.lid){
    if (!gesture.corridorDragMode && gesture.moved) {
      const a = stopById(gesture.anchorA), b = stopById(gesture.anchorB);
      if (a && b) {
        const segDx = b.x - a.x, segDy = b.y - a.y, segLen = Math.hypot(segDx, segDy) || 1;
        const dragDx = pos.x - gesture.startPt.x, dragDy = pos.y - gesture.startPt.y;
        const perpComp = Math.abs((-segDy * dragDx + segDx * dragDy) / segLen);
        const paraComp = Math.abs((segDx * dragDx + segDy * dragDy) / segLen);
        if (buildCorridors()[gesture.corridorKey]?.length > 1 && perpComp > paraComp && perpComp > 8) { gesture.corridorDragMode = 'reorder'; showCorridorHint(false); }
        else if (paraComp > 8 || h) { gesture.corridorDragMode = 'insert'; showCorridorHint(false); }
      }
    }
    if (gesture.corridorDragMode === 'reorder') {
      const a = stopById(gesture.anchorA), b = stopById(gesture.anchorB), corridor = buildCorridors()[gesture.corridorKey];
      if (a && b && corridor) {
        const dx = b.x - a.x, dy = b.y - a.y, len = Math.hypot(dx, dy) || 1, perpX = -dy / len, perpY = dx / len;
        const mx = pos.x - (a.x + b.x) / 2, my = pos.y - (a.y + b.y) / 2, perpOffset = mx * perpX + my * perpY;
        const [first] = [gesture.anchorA, gesture.anchorB].sort(), dirMult = gesture.anchorA === first ? 1 : -1;
        const adjustedOffset = perpOffset * dirMult, n = corridor.length;
        let targetIdx = clamp(Math.round(adjustedOffset / LINE_SPACING + (n - 1) / 2), 0, n - 1);
        const currentIdx = corridor.indexOf(gesture.lid);
        if (targetIdx !== currentIdx && currentIdx !== -1) {
          const newOrder = [...corridor]; newOrder.splice(currentIdx, 1); newOrder.splice(targetIdx, 0, gesture.lid);
          corridorOrders[gesture.corridorKey] = newOrder;
        }
      }
    } else if (gesture.corridorDragMode === 'insert') {
      if (h && gesture.lastAppliedHover !== h.id) { gesture.lastAppliedHover = h.id; toggleStationOnLineDuringInsert(lineById(gesture.lid), h.id); }
      else if (!h) { gesture.lastAppliedHover = null; }
    }
    render.refresh();
  } else if(gesture.mode==='extend' || gesture.mode==='newLine'){
    if(h){
      const idx = gesture.liveNodes.indexOf(h.id);
      if(idx === -1){ gesture.liveNodes.push(h.id); pulseStop(h.id); }
      else if(idx < gesture.liveNodes.length - 1){ gesture.liveNodes = gesture.liveNodes.slice(0, idx+1); pulseStop(h.id); }
      gesture.tempPoint = null;
    } else if(gesture.liveNodes.length){
      const lastNode = stopById(gesture.liveNodes[gesture.liveNodes.length-1]);
      const dx=pos.x-lastNode.x, dy=pos.y-lastNode.y, a=Math.round(Math.atan2(dy,dx)/(Math.PI/4))*(Math.PI/4);
      gesture.tempPoint = { x: lastNode.x+Math.cos(a)*dist(pos, lastNode), y: lastNode.y+Math.sin(a)*dist(pos, lastNode) };
    }
    render.refresh();
  }
});

$('app-svg').addEventListener('pointerup', e => {
  showCorridorHint(false);
  if(appState.panStart){ appState.panStart=null; return; }
  if(!gesture.active) return;
  const h = getStopNear(getMousePos(e), 32);
  if(gesture.mode==='tapEmpty' && !gesture.moved){
    const sPos = { x: snap(getMousePos(e).x), y: snap(getMousePos(e).y) };
    if(!getStopNear(sPos, 15)){ const id = 's'+Date.now(); stops.push({ id, ...sPos }); pulseStop(id); }
  } else if(gesture.mode==='newLine' && gesture.liveNodes.length >= 2 && h){
    lines.push({ id: 'l'+Date.now(), color: colorForNew(), nodes: [...gesture.liveNodes], bends: {} });
  } else if(gesture.mode==='extend' && gesture.lid){
    const l = lineById(gesture.lid);
    if(l){
      if(gesture.liveNodes.length >= 2) l.nodes = (gesture.liveNodes[0] === l.nodes[0]) ? [...gesture.liveNodes] : [...gesture.liveNodes].reverse();
      else lines = lines.filter(x => x.id !== l.id);
    }
  }
  gesture.active=false; render.refresh();
});

const io = {
  export(){
    const data = btoa(JSON.stringify({stops, lines, corridorOrders}));
    const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([$('app-svg').outerHTML.replace('<svg', `<svg xmlns="http://www.w3.org/2000/svg" data-metro="${data}"`)],{type:'image/svg+xml'})); a.download='metro.svg'; a.click();
  },
  import(inp){
    const r = new FileReader();
    r.onload = e => {
      try {
        const doc = new DOMParser().parseFromString(e.target.result,"image/svg+xml");
        const data = doc.querySelector('svg').dataset.metro;
        const d = JSON.parse(atob(data));
        stops=d.stops||[]; lines=d.lines||[]; corridorOrders=d.corridorOrders||{}; render.refresh();
      } catch(err) { console.error("Error importing:", err); }
    };
    if(inp.files[0]) r.readAsText(inp.files[0]);
  }
};

window.addEventListener('keydown', e => e.code==='Space'&&(appState.space=true));
window.addEventListener('keyup', e => e.code==='Space'&&(appState.space=false));
window.addEventListener('resize', setView);
$('app-svg').addEventListener('wheel', setViewOnWheel, {passive:false});

setView(); render.refresh();
</script>
</body>
</html>
