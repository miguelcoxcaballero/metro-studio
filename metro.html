<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Metro Studio Lite</title>
<script src="https://cdn.tailwindcss.com"></script>

<style>
  :root{
    --bg0:#f3f4f7;
    --bg1:#eceef3;
    --ink:#202124;
    --soft:#6b7280;
    --lc:#1a73e8;
  }

  html,body{
    margin:0; width:100%; height:100%;
    overflow:hidden; user-select:none;
    font-family:"Google Sans", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    background:
      radial-gradient(1200px 700px at 50% 45%, rgba(255,255,255,0.95), rgba(245,246,249,0.75) 55%, rgba(232,234,238,0.95) 100%),
      linear-gradient(180deg, var(--bg0), var(--bg1));
  }

  #app-svg{
    display:block; width:100%; height:100%;
    cursor:crosshair;
    touch-action:none;
  }

  .path{
    fill:none;
    stroke-linecap:round;
    stroke-linejoin:round;
    pointer-events:stroke;
    cursor:pointer;
    transition: opacity .15s ease, stroke-width .15s ease;
  }
  .path:hover{ stroke-width: 12.5px !important; }
  .path.sel{ stroke-width: 12px !important; }
  .path.dim{ opacity:.15; }
  .path.reordering{ stroke-width: 13px !important; filter: drop-shadow(0 0 6px currentColor); }

  #ghostShadow{ pointer-events:none; opacity:.15; }
  #ghost{
    pointer-events:none;
    opacity:.9;
    filter: drop-shadow(0 2px 3px rgba(0,0,0,.1));
  }

  .stop-shape{
    fill:#fff;
    stroke:var(--ink);
    stroke-width:3;
    vector-effect: non-scaling-stroke;
    transition: transform .12s ease;
    transform-box: fill-box;
    transform-origin:center;
  }
  .stop-ring{
    fill:none;
    stroke: var(--lc);
    stroke-width: 6;
    opacity: 0;
    vector-effect: non-scaling-stroke;
    transition: opacity .12s ease;
  }
  .stop.hover .stop-shape{ transform: scale(1.15); }
  .stop.onSel .stop-ring{ opacity: 0.8; }
  .stop.pulse .stop-shape{ animation: pulseAnim .25s cubic-bezier(.2,.9,.2,1.1); }

  @keyframes pulseAnim{
    0%{ transform:scale(1); }
    50%{ transform:scale(1.3); }
    100%{ transform:scale(1); }
  }

  .handle{ cursor: grab; }
  .handle:active{ cursor: grabbing; }

  header, #ui-panel{
    background: rgba(255,255,255,0.85) !important;
    backdrop-filter: blur(10px);
  }

  .corridor-hint{
    position: fixed;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 13px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
  }
  .corridor-hint.visible{ opacity: 1; }
</style>
</head>

<body>
  <header class="absolute top-4 left-4 right-4 h-14 rounded-2xl flex items-center justify-between px-6 shadow-sm z-50 border border-gray-200">
    <div class="flex items-center gap-2 text-gray-800 font-medium">
      <div class="p-1.5 bg-blue-50 rounded text-blue-600">
        <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.52 2 12 2zm0 18c-4.4 0-8-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8zm-5.5-2.5l7.5-3.2-7.5-3.2V17.5z"/></svg>
      </div>
      Metro Studio Lite
    </div>
    <div class="flex gap-2">
      <button onclick="$('inp').click()" class="px-4 py-2 hover:bg-gray-100 rounded-xl text-sm font-medium transition-colors">Importar</button>
      <input id="inp" type="file" hidden onchange="io.import(this)">
      <button onclick="io.export()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-xl text-sm font-medium shadow-sm transition-all">Exportar</button>
    </div>
  </header>

  <div id="ui-panel" class="absolute bottom-6 left-6 w-64 max-h-[40vh] overflow-y-auto rounded-2xl p-2 shadow-xl border border-gray-200 z-40 flex flex-col-reverse gap-2 empty:hidden"></div>

  <div id="corridor-hint" class="corridor-hint">Arrastra lateralmente para reordenar líneas en el corredor</div>

  <svg id="app-svg" preserveAspectRatio="xMidYMid slice">
    <defs>
      <pattern id="grid-pattern" x="-20" y="-20" width="40" height="40" patternUnits="userSpaceOnUse">
        <circle cx="20" cy="20" r="1.5" fill="#cbd5e1"/>
      </pattern>
      <radialGradient id="vignette" cx="50%" cy="45%" r="70%">
        <stop offset="0%" stop-color="rgba(0,0,0,0)" /><stop offset="100%" stop-color="rgba(0,0,0,0.05)" />
      </radialGradient>
    </defs>
    <rect x="-10000" y="-10000" width="20000" height="20000" fill="url(#grid-pattern)"></rect>
    <rect x="-10000" y="-10000" width="20000" height="20000" fill="url(#vignette)" pointer-events="none"></rect>

    <g id="lines-layer"></g>
    <g id="edit-layer"></g>

    <polyline id="ghostShadow" fill="none" stroke="#000" stroke-width="16" stroke-linecap="round" stroke-linejoin="round" style="display:none"></polyline>
    <polyline id="ghost" fill="none" stroke="var(--lc)" stroke-width="11" stroke-linecap="round" stroke-linejoin="round" style="display:none"></polyline>

    <g id="handles-layer"></g>
    <g id="stops-layer"></g>
  </svg>

<script>
/* ========= CONFIGURACIÓN Y ESTADO ========= */
const GRID = 40;
const LINE_WIDTH = 10;
const LINE_SPACING = 12;
// IMPORTANTE: ya NO “suavizamos” (nada de transiciones que parezcan curvas)
// todo son esquinas como el resto: intersección/miter o, si hace falta, bisel recto.
const MITER_LIMIT = 6; // múltiplo del offset (recorta miters raros)

let stops = [];
let lines = [];
let corridorOrders = {}; // por "chunk" del grid: "x1,y1|x2,y2"

const colors = ['#EA4335','#4285F4','#34A853','#F4C20D','#AB47BC','#FF6D00'];
let view = { x: 500, y: 375, w: 1000, h: 750 };

const appState = { selectedLineId: null, space: false, panStart: null, mouseRaw: {x:0, y:0} };

const gesture = {
  active: false,
  mode: null,
  moved: false,
  startPt: null,
  lid: null,
  liveNodes: [],
  hoverStopId: null,
  tempPoint: null,
  anchorA: null,
  anchorB: null,
  lastAppliedHover: null,
  originalLineNodes: [],
  corridorDragMode: null,
  corridorOriginalOrder: [],
  corridorChunkKey: null,
  corridorChunkA: null,
  corridorChunkB: null
};

/* ========= UTILIDADES BÁSICAS ========= */
const $ = id => document.getElementById(id);
const attr = (el, a) => { for (const k in a) el.setAttribute(k, a[k]); };
const dist = (a,b) => Math.hypot(a.x-b.x, a.y-b.y);
const snap = v => Math.round(v / GRID) * GRID;
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const snapLen = v => Math.round(v / GRID) * GRID;

function getMousePos(evt){
  const svg = $('app-svg'), p = svg.createSVGPoint();
  p.x = evt.clientX; p.y = evt.clientY;
  return p.matrixTransform(svg.getScreenCTM().inverse());
}

function stopById(id){ return stops.find(s=>s.id===id); }
function lineById(id){ return lines.find(l=>l.id===id); }

function getStopNear(pos, d=26){
  let best=null, bd=Infinity;
  for(const s of stops){
    const dd = Math.hypot(s.x-pos.x, s.y-pos.y);
    if(dd<d && dd<bd){ bd=dd; best=s; }
  }
  return best;
}

function pulseStop(id){
  const g = $(id); if(!g) return;
  g.classList.remove('pulse'); void g.offsetWidth; g.classList.add('pulse');
}

function distPointToSeg(p,a,b){
  const vx=b.x-a.x, vy=b.y-a.y, wx=p.x-a.x, wy=p.y-a.y;
  const vv = vx*vx+vy*vy || 1;
  let t = Math.max(0, Math.min(1,(wx*vx+wy*vy)/vv));
  return Math.hypot(p.x-(a.x+t*vx), p.y-(a.y+t*vy));
}

function getNormal(p1, p2) {
  const dx = p2.x - p1.x, dy = p2.y - p1.y;
  const len = Math.hypot(dx, dy) || 1;
  return { x: -dy / len, y: dx / len };
}

function getTangent(p1, p2) {
  const dx = p2.x - p1.x, dy = p2.y - p1.y;
  const len = Math.hypot(dx, dy) || 1;
  return { x: dx / len, y: dy / len };
}

function pointsToAttr(pts){ return pts.map(p => `${p.x},${p.y}`).join(' '); }

function setView(){
  view.h = view.w * (window.innerHeight / window.innerWidth);
  attr($('app-svg'), { viewBox: `${view.x} ${view.y} ${view.w} ${view.h}` });
}

function setViewOnWheel(e){
  e.preventDefault();
  const nw = view.w * Math.pow(1.1, e.deltaY > 0 ? 1 : -1);
  if(nw<100 || nw>10000) return;
  const mx=e.offsetX/window.innerWidth, my=e.offsetY/window.innerHeight;
  view.x += mx*(view.w-nw);
  view.y += my*(view.h-(nw*(window.innerHeight / window.innerWidth)));
  view.w = nw; setView();
}

/* ========= CHUNKS DE GRID PARA CORREDORES REALES ========= */

// clave canónica para un chunk dirección-less
function chunkKey(p, q){
  const ax = p.x, ay = p.y, bx = q.x, by = q.y;
  if (ax < bx || (ax === bx && ay <= by)) return `${ax},${ay}|${bx},${by}`;
  return `${bx},${by}|${ax},${ay}`;
}

// parsea "x1,y1|x2,y2"
function parseChunkKey(key){
  const [a,b] = key.split('|');
  const [ax,ay] = a.split(',').map(Number);
  const [bx,by] = b.split(',').map(Number);
  return { ax, ay, bx, by };
}

// normal estable SOLO para UI de reordenado (no para geometría de offsets)
function stableNormalForChunkKeyWithRefs(key, refs){
  // refs guarda una dirección "de referencia" real (primera vez que se ve el chunk)
  // esto evita que en NE/SW cambie el “lado” por culpa del orden canónico x/y.
  const ref = refs?.[key];
  if(ref){
    const len = Math.hypot(ref.dx, ref.dy) || 1;
    return { x: -ref.dy/len, y: ref.dx/len };
  }
  // fallback si no hay ref (no debería pasar)
  const {ax,ay,bx,by} = parseChunkKey(key);
  const dx = bx-ax, dy = by-ay;
  const len = Math.hypot(dx,dy) || 1;
  return { x: -dy/len, y: dx/len };
}

// intersección de dos rectas infinitas: P + tR con Q + uS
function lineLineIntersection(P, R, Q, S){
  const rxs = R.x*S.y - R.y*S.x;
  if(Math.abs(rxs) < 1e-9) return null; // paralelas/colineales
  const QmP = { x: Q.x - P.x, y: Q.y - P.y };
  const t = (QmP.x*S.y - QmP.y*S.x) / rxs;
  return { x: P.x + t*R.x, y: P.y + t*R.y };
}

// expande una lista de puntos (tramos axis/diag) a puntos cada GRID (denso)
function densifyRoute(routePts){
  const out = [];
  for(let i=0;i<routePts.length;i++){
    const p = routePts[i];
    if(out.length===0) out.push({x:p.x,y:p.y});
    if(i===routePts.length-1) break;
    const q = routePts[i+1];
    const dx = q.x - p.x, dy = q.y - p.y;
    const steps = Math.round(Math.max(Math.abs(dx), Math.abs(dy)) / GRID) || 1;
    const sx = Math.sign(dx) * (Math.abs(dx)?GRID:0);
    const sy = Math.sign(dy) * (Math.abs(dy)?GRID:0);
    let cx = p.x, cy = p.y;
    for(let k=0;k<steps;k++){
      cx += sx; cy += sy;
      const last = out[out.length-1];
      if(!last || last.x!==cx || last.y!==cy) out.push({x:cx,y:cy});
    }
  }
  return out;
}

// comprime puntos colineales consecutivos para reducir polyline (manteniendo esquinas)
function compressColinear(pts){
  if(pts.length<=2) return pts;
  const out = [pts[0]];
  for(let i=1;i<pts.length-1;i++){
    const a = out[out.length-1], b = pts[i], c = pts[i+1];
    const abx=b.x-a.x, aby=b.y-a.y, bcx=c.x-b.x, bcy=c.y-b.y;
    if(abx*bcy - aby*bcx === 0) continue;
    out.push(b);
  }
  out.push(pts[pts.length-1]);
  return out;
}

/* ========= MOTOR DE RUTAS ========= */

function calculateRoute(p1, p2, influencePt){
  const A = { x: p1.x, y: p1.y };
  const B = { x: p2.x, y: p2.y };
  const dx = B.x - A.x, dy = B.y - A.y;
  const adx = Math.abs(dx), ady = Math.abs(dy);

  if(adx < 0.5 || ady < 0.5) return [A, B];
  if(Math.abs(adx - ady) < 0.5) return [A, B];

  const sx = Math.sign(dx), sy = Math.sign(dy);
  const diag = Math.min(adx, ady);
  const extra = Math.abs(adx - ady);
  const dom = (adx > ady) ? 'x' : 'y';

  let pre = extra / 2;
  if(influencePt){
    if(dom === 'x'){
      const prog = (influencePt.x - A.x) * sx;
      pre = prog - diag / 2;
    } else {
      const prog = (influencePt.y - A.y) * sy;
      pre = prog - diag / 2;
    }
  }
  pre = snapLen(pre);
  pre = clamp(pre, 0, extra);
  const post = extra - pre;

  const pts = [A];
  const pushIfNew = (p) => {
    const last = pts[pts.length-1];
    if(!last || Math.abs(last.x - p.x) > 0.5 || Math.abs(last.y - p.y) > 0.5) pts.push(p);
  };

  if(dom === 'x'){
    const P1 = { x: A.x + sx*pre,      y: A.y };
    const P2 = { x: P1.x + sx*diag,    y: P1.y + sy*diag };
    const P3 = { x: P2.x + sx*post,    y: P2.y };
    pushIfNew(P1); pushIfNew(P2); pushIfNew(P3);
  } else {
    const P1 = { x: A.x,               y: A.y + sy*pre };
    const P2 = { x: P1.x + sx*diag,    y: P1.y + sy*diag };
    const P3 = { x: P2.x,              y: P2.y + sy*post };
    pushIfNew(P1); pushIfNew(P2); pushIfNew(P3);
  }
  pushIfNew(B);
  return pts;
}

/* ========= CORREDORES: SOLO EN TROZOS COMPARTIDOS DEL GRID =========
   + referencia de dirección por chunk (evita el “flip” NE/SW que causa trenzado)
*/

function buildCorridors(){
  const map = {};
  const refs = {}; // key -> {dx,dy} (dirección de referencia real)

  for(const line of lines){
    if(!line.nodes || line.nodes.length<2) continue;
    if(!line.bends) line.bends = {};

    for(let i=0;i<line.nodes.length-1;i++){
      const a = stopById(line.nodes[i]), b = stopById(line.nodes[i+1]);
      if(!a || !b) continue;

      const bendKey = [a.id, b.id].sort().join('-');
      const influence = line.bends[bendKey] || { x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
      const route = calculateRoute(a, b, influence);
      const dense = densifyRoute(route);

      for(let k=0;k<dense.length-1;k++){
        const p = dense[k], q = dense[k+1];
        const key = chunkKey(p,q);

        if(!map[key]) map[key] = [];
        if(!map[key].includes(line.id)) map[key].push(line.id);

        // fija referencia SOLO la primera vez que vemos este chunk,
        // usando la dirección REAL p->q (no el orden canónico x/y).
        if(!refs[key]) refs[key] = { dx: q.x - p.x, dy: q.y - p.y };
      }
    }
  }

  // aplica orden guardado por chunkKey
  for(const key in map){
    const ids = map[key];
    if(corridorOrders[key]){
      const saved = corridorOrders[key].filter(id => ids.includes(id));
      const extra = ids.filter(id => !saved.includes(id));
      map[key] = [...saved, ...extra];
    }
  }

  return { map, refs };
}

// offset para un CHUNK concreto:
// - base depende del índice en corridorOrders (orden)
// - flip depende de si este tramo p->q va en sentido opuesto a la ref del chunk
//   (esto arregla el trenzado en giros NE/SW porque ya no cambia “el lado” al girar)
function getCorridorInfoChunk(lineId, p, q, corridorsMap, refs){
  const key = chunkKey(p,q);
  const corridor = corridorsMap?.[key];
  if(!corridor || corridor.length < 2) return { offset: 0, count: 1, index: 0, key, flip: 1 };

  const n = corridor.length;
  const idx = corridor.indexOf(lineId);
  if(idx === -1) return { offset: 0, count: 1, index: 0, key, flip: 1 };

  const base = (idx - (n - 1)/2) * LINE_SPACING;

  const ref = refs?.[key];
  let flip = 1;
  if(ref){
    const dx = q.x - p.x, dy = q.y - p.y;
    const dot = dx*ref.dx + dy*ref.dy;
    if(dot < 0) flip = -1;
  }
  // devolver offset ya con flip (así la normal puede ser la normal de viaje sin “twists”)
  return { offset: base * flip, count: n, index: idx, key, flip };
}

/* ========= BUILD PATH: SIN “CURVAS” + SIN TRENZADO EN NE/SW =========
   - Offset por chunk real (solo donde coincide el camino del grid)
   - Lado estable usando refs (evita flip raro en vertical/diagonal)
   - Uniones por intersección (miter) o bisel recto si paralelas / miter enorme
*/

function buildLinePath(lineObj, nodeIds, corridorsObj){
  if(!nodeIds || nodeIds.length < 2) return [];
  if(!lineObj.bends) lineObj.bends = {};

  const corridorsMap = corridorsObj?.map || null;
  const refs = corridorsObj?.refs || null;

  // 1) ruta base densificada por GRID (sin offset)
  const basePts = [];
  for(let i=0;i<nodeIds.length-1;i++){
    const a = stopById(nodeIds[i]), b = stopById(nodeIds[i+1]);
    if(!a || !b) continue;

    const bendKey = [a.id, b.id].sort().join('-');
    let influence = lineObj.bends[bendKey] || { x:(a.x+b.x)/2, y:(a.y+b.y)/2 };

    const isEditing =
      gesture.active && gesture.mode === 'segment' && gesture.corridorDragMode === 'insert' &&
      gesture.lid === lineObj.id &&
      ((gesture.anchorA === a.id && gesture.anchorB === b.id) || (gesture.anchorA === b.id && gesture.anchorB === a.id));

    if(isEditing && gesture.moved){
      influence = appState.mouseRaw;
      lineObj.bends[bendKey] = { x: influence.x, y: influence.y };
    }

    const route = calculateRoute(a, b, influence);
    const dense = densifyRoute(route);

    for(let k=0;k<dense.length;k++){
      const p = dense[k];
      const last = basePts[basePts.length-1];
      if(!last || last.x!==p.x || last.y!==p.y) basePts.push(p);
    }
  }
  if(basePts.length < 2) return [];

  // 2) offsets por micro-segmento (chunk)
  const offs = [];
  const norms = [];
  for(let i=0;i<basePts.length-1;i++){
    const p = basePts[i], q = basePts[i+1];
    const info = corridorsMap ? getCorridorInfoChunk(lineObj.id, p, q, corridorsMap, refs) : { offset: 0 };
    offs[i] = info.offset || 0;
    // normal de VIAJE (p->q). El offset ya lleva el flip, así NO hay “twist” al girar.
    norms[i] = getNormal(p, q);
  }

  const out = [];
  const push = (pt) => {
    const last = out[out.length-1];
    if(!last || Math.abs(last.x-pt.x)>0.01 || Math.abs(last.y-pt.y)>0.01) out.push(pt);
  };

  // start
  {
    const p0 = basePts[0];
    const n0 = norms[0];
    const o0 = offs[0] || 0;
    push({ x: p0.x + n0.x*o0, y: p0.y + n0.y*o0 });
  }

  // vertices
  for(let i=1;i<basePts.length-1;i++){
    const pPrev = basePts[i-1], p = basePts[i], pNext = basePts[i+1];

    const offPrev = offs[i-1] || 0;
    const offNext = offs[i] || 0;

    const nPrev = norms[i-1];
    const nNext = norms[i];

    // puntos “anclaje” en el vértice para cada recta offset
    const A = { x: p.x + nPrev.x*offPrev, y: p.y + nPrev.y*offPrev };
    const B = { x: p.x + nNext.x*offNext, y: p.y + nNext.y*offNext };

    // direcciones de cada segmento (no unitarias)
    const d1 = { x: p.x - pPrev.x, y: p.y - pPrev.y };
    const d2 = { x: pNext.x - p.x, y: pNext.y - p.y };

    // si los offsets son “casi iguales”, el miter normal va perfecto y no cruza
    // si son distintos, también usamos intersección (esquina normal) SIN transiciones “curvas”.
    const I = lineLineIntersection(A, d1, B, d2);

    if(I){
      // recorta miters absurdos (esto evita picos que pueden parecer “trenzado” en diagonales)
      const lim = Math.max(Math.abs(offPrev), Math.abs(offNext), LINE_SPACING) * MITER_LIMIT;
      const dI = dist(I, p);
      if(dI <= lim){
        push(I);
      }else{
        // fallback: bisel recto (sigue siendo “como el resto”: líneas rectas, sin curvar)
        push(A);
        push(B);
      }
    }else{
      // paralelas/colineales: conecta con bisel (recto, sin curva)
      push(A);
      push(B);
    }
  }

  // end
  {
    const pn_1 = basePts[basePts.length-2];
    const pn = basePts[basePts.length-1];
    const nL = norms[norms.length-1];
    const oL = offs[offs.length-1] || 0;
    push({ x: pn.x + nL.x*oL, y: pn.y + nL.y*oL });
  }

  return compressColinear(out);
}

/* ========= UTILIDADES PARA SELECCIÓN DE TRAMOS ========= */

function findNearestLinkOnLine(lid, pos){
  const l = lineById(lid); if(!l || l.nodes.length<2) return null;
  const corridorsObj = buildCorridors();
  const pts = buildLinePath(l, l.nodes, corridorsObj);
  if(pts.length<2) return null;

  let best = { i: 0, d: Infinity };
  for(let k = 0; k < pts.length - 1; k++){
    const d = distPointToSeg(pos, pts[k], pts[k+1]);
    if(d < best.d) best = { i: k, d };
  }

  // nodeIdx para insertar (como antes)
  let nodeIdx = 0, minDist = Infinity;
  for(let i=0; i<l.nodes.length-1; i++){
    const a = stopById(l.nodes[i]), b = stopById(l.nodes[i+1]);
    if(!a || !b) continue;
    const dNode = distPointToSeg(pos, a, b);
    if(dNode < minDist) { minDist = dNode; nodeIdx = i; }
  }

  return { i: nodeIdx, d: best.d };
}

// chunk base más cercano (para reordenado real por corredor)
function findNearestChunkOnLine(lid, pos){
  const l = lineById(lid); if(!l || l.nodes.length<2) return null;
  if(!l.bends) l.bends = {};
  const corridorsObj = buildCorridors();
  const corridorsMap = corridorsObj.map;

  // reconstruimos base densificada (sin offset)
  const basePts = [];
  for(let i=0;i<l.nodes.length-1;i++){
    const a = stopById(l.nodes[i]), b = stopById(l.nodes[i+1]);
    if(!a || !b) continue;
    const bendKey = [a.id, b.id].sort().join('-');
    const influence = l.bends[bendKey] || { x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
    const dense = densifyRoute(calculateRoute(a,b,influence));
    for(const p of dense){
      const last = basePts[basePts.length-1];
      if(!last || last.x!==p.x || last.y!==p.y) basePts.push(p);
    }
  }
  if(basePts.length<2) return null;

  let best = { d: Infinity, a:null, b:null, key:null, hasCorridor:false };
  for(let i=0;i<basePts.length-1;i++){
    const p = basePts[i], q = basePts[i+1];
    const d = distPointToSeg(pos, p, q);
    if(d < best.d){
      const key = chunkKey(p,q);
      best = { d, a:p, b:q, key, hasCorridor: (corridorsMap[key] && corridorsMap[key].length>1) };
    }
  }
  return best;
}

function findEndpointAtStop(stopId){
  const list = appState.selectedLineId ? [lineById(appState.selectedLineId), ...lines] : lines;
  for(const l of list){
    if(!l || !l.nodes || l.nodes.length<1) continue;
    if(l.nodes[0] === stopId) return { lid:l.id, end:'start' };
    if(l.nodes[l.nodes.length-1] === stopId) return { lid:l.id, end:'end' };
  }
  return null;
}

/* ========= RENDER ========= */
const render = {
  refresh(){
    this.renderLines();
    this.renderStops();
    this.renderHandles();
    this.renderUI();
    this.renderGhost();
  },

  renderLines(){
    const layer = $('lines-layer'), edit = $('edit-layer');
    layer.innerHTML = ''; edit.innerHTML = '';
    const drawing = gesture.active && gesture.lid && (gesture.mode === 'extend');
    const corridorsObj = buildCorridors();

    for(const l of lines){
      if(l.nodes.length < 2) continue;
      if(drawing && l.id === gesture.lid) continue;
      const pts = buildLinePath(l, l.nodes, corridorsObj);
      if (pts.length < 2) continue;
      const pl = document.createElementNS("http://www.w3.org/2000/svg","polyline");
      pl.classList.add('path');
      if(appState.selectedLineId === l.id) pl.classList.add('sel');
      if(gesture.mode === 'segment' && gesture.corridorDragMode === 'reorder' && gesture.lid === l.id) pl.classList.add('reordering');
      attr(pl,{ points: pointsToAttr(pts), stroke: l.color, 'stroke-width': LINE_WIDTH, 'data-lid': l.id });
      layer.appendChild(pl);
    }

    if(drawing){
      const l = lineById(gesture.lid);
      const pl = document.createElementNS("http://www.w3.org/2000/svg","polyline");
      pl.classList.add('path','dim');
      attr(pl,{ points: pointsToAttr(buildLinePath(l, gesture.originalLineNodes, corridorsObj)), stroke: l.color, 'stroke-width': LINE_WIDTH });
      edit.appendChild(pl);
    }
  },

  renderStops(){
    const layer = $('stops-layer'); layer.innerHTML = '';
    let selNodes = gesture.active && gesture.mode !== 'segment' && gesture.liveNodes?.length
      ? new Set(gesture.liveNodes) : new Set(lineById(gesture.lid || appState.selectedLineId)?.nodes || []);

    stops.forEach(s => {
      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      g.id = s.id; g.classList.add('stop');
      if(selNodes.has(s.id)) g.classList.add('onSel');
      if(gesture.hoverStopId === s.id) g.classList.add('hover');
      const ring = document.createElementNS("http://www.w3.org/2000/svg","circle");
      ring.classList.add('stop-ring'); attr(ring,{cx:s.x, cy:s.y, r:16});
      const shape = document.createElementNS("http://www.w3.org/2000/svg","circle");
      shape.classList.add('stop-shape'); attr(shape,{cx:s.x, cy:s.y, r:13.5});
      const hit = document.createElementNS("http://www.w3.org/2000/svg","circle");
      attr(hit,{cx:s.x, cy:s.y, r:22, fill:"transparent"});
      g.append(ring, shape, hit); layer.appendChild(g);
    });
  },

  renderHandles(){
    const layer = $('handles-layer'); layer.innerHTML = '';
    const l = lineById(appState.selectedLineId);
    if(!l || l.nodes.length<2 || gesture.active) return;
    const corridorsObj = buildCorridors();
    const pts = buildLinePath(l, l.nodes, corridorsObj);
    if (pts.length < 2) return;
    const mk = (p, toward, end) => {
      const dx=p.x-toward.x, dy=p.y-toward.y, len=Math.hypot(dx,dy)||1, ux=dx/len, uy=dy/len, px=-uy, py=ux;
      const cx=p.x+ux*12, cy=p.y+uy*12;
      const line = document.createElementNS("http://www.w3.org/2000/svg","line");
      attr(line,{x1:cx+px*12, y1:cy+py*12, x2:cx-px*12, y2:cy-py*12, stroke:l.color, 'stroke-width':10, class:'handle','data-lid':l.id,'data-end':end});
      layer.appendChild(line);
    };
    mk(pts[0], pts[1], 'start');
    mk(pts[pts.length-1], pts[pts.length-2], 'end');
  },

  renderUI(){
    $('ui-panel').innerHTML = lines.map((l,i) => `
      <div class="flex items-center p-2 rounded-xl gap-3 cursor-pointer ${appState.selectedLineId===l.id?'bg-blue-50 ring-1 ring-blue-200 shadow-sm' : 'bg-white border border-gray-100'}"
           onclick="appState.selectedLineId='${l.id}';render.refresh()">
        <div class="w-5 h-5 rounded-full" style="background:${l.color}"></div>
        <span class="text-sm font-semibold text-gray-700">Línea ${i+1}</span>
      </div>`).join('');
  },

  renderGhost(){
    const g = $('ghost'), sh = $('ghostShadow');
    if(!gesture.active || gesture.mode === 'segment' || !gesture.liveNodes.length){
      g.style.display = sh.style.display = 'none'; return;
    }
    const color = gesture.lid ? (lineById(gesture.lid)?.color || colors[0]) : colorForNew();
    $('app-svg').style.setProperty('--lc', color);
    let pts = buildLinePath({bends:{}}, gesture.liveNodes, null);
    if(gesture.tempPoint){
      const last = stopById(gesture.liveNodes[gesture.liveNodes.length-1]);
      const route = calculateRoute(last, gesture.tempPoint, appState.mouseRaw);
      route.shift(); pts = pts.concat(route);
    }
    const attrVal = pointsToAttr(pts);
    g.style.display = sh.style.display = 'block'; g.setAttribute('points', attrVal); sh.setAttribute('points', attrVal);
  }
};

/* ========= INTERACCIÓN ========= */
function colorForNew(){
  const used = new Set(lines.map(l=>l.color));
  return colors.find(c=>!used.has(c)) || colors[lines.length%colors.length];
}

function showCorridorHint(show) {
  const hint = $('corridor-hint');
  if (show) hint.classList.add('visible');
  else hint.classList.remove('visible');
}

function toggleStationOnLineDuringInsert(l, sid){
  if(!l || !sid || sid === gesture.anchorA || sid === gesture.anchorB) return;
  const already = l.nodes.indexOf(sid);
  if(already !== -1){
    l.nodes = l.nodes.filter(x => x !== sid);
    if(l.nodes.length < 2) lines = lines.filter(x => x.id !== l.id);
    pulseStop(sid);
  } else {
    const insIdx = l.nodes.indexOf(gesture.anchorB);
    l.nodes.splice(insIdx, 0, sid);
    pulseStop(sid);
  }
}

$('app-svg').addEventListener('pointerdown', e => {
  if(e.button===1 || appState.space){ appState.panStart={x:e.clientX, y:e.clientY, vx:view.x, vy:view.y}; return; }
  const pos = getMousePos(e), hStop = getStopNear(pos), hPath = e.target.closest('.path'), hCap = e.target.closest('.handle');

  Object.assign(gesture, {
    active: true, moved: false, startPt: pos,
    lid: null, liveNodes: [], tempPoint: null,
    anchorA: null, anchorB: null, lastAppliedHover: null,
    originalLineNodes: [],
    corridorDragMode: null, corridorOriginalOrder: [],
    corridorChunkKey: null, corridorChunkA: null, corridorChunkB: null
  });

  if(hCap){
    const l = lineById(hCap.dataset.lid);
    gesture.mode='extend'; gesture.lid=l.id; appState.selectedLineId = l.id;
    gesture.liveNodes = hCap.dataset.end==='start' ? [...l.nodes].reverse() : [...l.nodes];
    gesture.originalLineNodes = [...l.nodes];
  } else if(hStop){
    const ep = findEndpointAtStop(hStop.id);
    if(ep){
      gesture.mode='extend'; gesture.lid=ep.lid; appState.selectedLineId = ep.lid;
      const l = lineById(ep.lid); gesture.liveNodes = ep.end==='start' ? [...l.nodes].reverse() : [...l.nodes];
      gesture.originalLineNodes = [...l.nodes];
    } else { gesture.mode='newLine'; gesture.liveNodes = [hStop.id]; }
  } else if(hPath){
    const lid = hPath.dataset.lid;
    const hit = findNearestLinkOnLine(lid, pos);

    if(hit && hit.d <= 22){
      appState.selectedLineId = lid; gesture.mode = 'segment'; gesture.lid = lid;
      const l = lineById(lid);
      gesture.anchorA = l.nodes[hit.i];
      gesture.anchorB = l.nodes[hit.i + 1];
      gesture.originalLineNodes = [...l.nodes];

      const nearestChunk = findNearestChunkOnLine(lid, pos);
      if(nearestChunk && nearestChunk.hasCorridor){
        gesture.corridorChunkKey = nearestChunk.key;
        gesture.corridorChunkA = nearestChunk.a;
        gesture.corridorChunkB = nearestChunk.b;
        const corridorsObj = buildCorridors();
        gesture.corridorOriginalOrder = [...(corridorsObj.map[gesture.corridorChunkKey]||[])];
        showCorridorHint(true);
      }
    } else { appState.selectedLineId = lid; gesture.mode = 'select'; gesture.active = false; }
  } else { gesture.mode='tapEmpty'; appState.selectedLineId = null; }

  render.refresh();
});

$('app-svg').addEventListener('pointermove', e => {
  const pos = getMousePos(e); appState.mouseRaw = pos;

  if(appState.panStart){
    view.x = appState.panStart.vx - (e.clientX - appState.panStart.x)*(view.w/window.innerWidth);
    view.y = appState.panStart.vy - (e.clientY - appState.panStart.y)*(view.h/window.innerHeight);
    setView(); return;
  }
  if(!gesture.active) return;
  if(!gesture.moved && dist(pos, gesture.startPt)>6) gesture.moved=true;

  const h = getStopNear(pos, 32); gesture.hoverStopId = h ? h.id : null;

  if(gesture.mode === 'segment' && gesture.lid){
    if(!gesture.corridorDragMode && gesture.moved){
      const a = stopById(gesture.anchorA), b = stopById(gesture.anchorB);
      if(a && b){
        const segDx = b.x - a.x, segDy = b.y - a.y, segLen = Math.hypot(segDx, segDy) || 1;
        const dragDx = pos.x - gesture.startPt.x, dragDy = pos.y - gesture.startPt.y;
        const perpComp = Math.abs((-segDy * dragDx + segDx * dragDy) / segLen);
        const paraComp = Math.abs((segDx * dragDx + segDy * dragDy) / segLen);

        if(gesture.corridorChunkKey && perpComp > paraComp && perpComp > 8){
          gesture.corridorDragMode = 'reorder';
          showCorridorHint(false);
        }else if(paraComp > 8 || h){
          gesture.corridorDragMode = 'insert';
          showCorridorHint(false);
        }
      }
    }

    if(gesture.corridorDragMode === 'reorder'){
      const corridorsObj = buildCorridors();
      const corridorsMap = corridorsObj.map;
      const refs = corridorsObj.refs;

      const key = gesture.corridorChunkKey;
      const corridor = key ? corridorsMap[key] : null;

      if(corridor && corridor.length>1 && key){
        // usamos la normal estable basada en la referencia REAL del chunk (anti-flip NE/SW)
        const nStable = stableNormalForChunkKeyWithRefs(key, refs);

        const A = gesture.corridorChunkA, B = gesture.corridorChunkB;
        const midx = (A.x+B.x)/2, midy=(A.y+B.y)/2;

        const mx = pos.x - midx, my = pos.y - midy;
        const perpOffset = mx*nStable.x + my*nStable.y;

        const n = corridor.length;
        let targetIdx = clamp(Math.round(perpOffset / LINE_SPACING + (n - 1)/2), 0, n - 1);
        const currentIdx = corridor.indexOf(gesture.lid);

        if(targetIdx !== currentIdx && currentIdx !== -1){
          const newOrder = [...corridor];
          newOrder.splice(currentIdx,1);
          newOrder.splice(targetIdx,0,gesture.lid);
          corridorOrders[key] = newOrder;
        }
      }
    }else if(gesture.corridorDragMode === 'insert'){
      if(h && gesture.lastAppliedHover !== h.id){ gesture.lastAppliedHover = h.id; toggleStationOnLineDuringInsert(lineById(gesture.lid), h.id); }
      else if(!h){ gesture.lastAppliedHover = null; }
    }

    render.refresh();
  } else if(gesture.mode==='extend' || gesture.mode==='newLine'){
    if(h){
      const idx = gesture.liveNodes.indexOf(h.id);
      if(idx === -1){ gesture.liveNodes.push(h.id); pulseStop(h.id); }
      else if(idx < gesture.liveNodes.length - 1){ gesture.liveNodes = gesture.liveNodes.slice(0, idx+1); pulseStop(h.id); }
      gesture.tempPoint = null;
    } else if(gesture.liveNodes.length){
      const lastNode = stopById(gesture.liveNodes[gesture.liveNodes.length-1]);
      const dx=pos.x-lastNode.x, dy=pos.y-lastNode.y;
      const a=Math.round(Math.atan2(dy,dx)/(Math.PI/4))*(Math.PI/4);
      gesture.tempPoint = { x: lastNode.x+Math.cos(a)*dist(pos, lastNode), y: lastNode.y+Math.sin(a)*dist(pos, lastNode) };
    }
    render.refresh();
  }
});

$('app-svg').addEventListener('pointerup', e => {
  showCorridorHint(false);
  if(appState.panStart){ appState.panStart=null; return; }
  if(!gesture.active) return;

  const h = getStopNear(getMousePos(e), 32);

  if(gesture.mode==='tapEmpty' && !gesture.moved){
    const sPos = { x: snap(getMousePos(e).x), y: snap(getMousePos(e).y) };
    if(!getStopNear(sPos, 15)){ const id = 's'+Date.now(); stops.push({ id, ...sPos }); pulseStop(id); }
  } else if(gesture.mode==='newLine' && gesture.liveNodes.length >= 2 && h){
    lines.push({ id: 'l'+Date.now(), color: colorForNew(), nodes: [...gesture.liveNodes], bends: {} });
  } else if(gesture.mode==='extend' && gesture.lid){
    const l = lineById(gesture.lid);
    if(l){
      if(gesture.liveNodes.length >= 2) l.nodes = (gesture.liveNodes[0] === l.nodes[0]) ? [...gesture.liveNodes] : [...gesture.liveNodes].reverse();
      else lines = lines.filter(x => x.id !== l.id);
    }
  }

  gesture.active=false; render.refresh();
});

const io = {
  export(){
    const data = btoa(JSON.stringify({stops, lines, corridorOrders}));
    const a = document.createElement('a');
    a.href = URL.createObjectURL(new Blob(
      [$('app-svg').outerHTML.replace('<svg', `<svg xmlns="http://www.w3.org/2000/svg" data-metro="${data}"`)],
      {type:'image/svg+xml'}
    ));
    a.download='metro.svg'; a.click();
  },
  import(inp){
    const r = new FileReader();
    r.onload = e => {
      try {
        const doc = new DOMParser().parseFromString(e.target.result,"image/svg+xml");
        const data = doc.querySelector('svg').dataset.metro;
        const d = JSON.parse(atob(data));
        stops=d.stops||[]; lines=d.lines||[]; corridorOrders=d.corridorOrders||{};
        render.refresh();
      } catch(err) { console.error("Error importing:", err); }
    };
    if(inp.files[0]) r.readAsText(inp.files[0]);
  }
};

window.addEventListener('keydown', e => e.code==='Space'&&(appState.space=true));
window.addEventListener('keyup', e => e.code==='Space'&&(appState.space=false));
window.addEventListener('resize', setView);
$('app-svg').addEventListener('wheel', setViewOnWheel, {passive:false});

setView(); render.refresh();
</script>
</body>
</html>
